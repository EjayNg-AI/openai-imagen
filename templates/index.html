<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>OpenAI Image‑API Playground</title>
    <style>
      :root {
        --bg: #090d18;
        --fg: #e6edf7;
        --panel: #121a2c;
        --panel-border: #1d2738;
        --accent: #4f8cff;
        --accent-hover: #70a1ff;
        --accent-active: #3f76d6;
        --muted: #97a5c4;
        --input-bg: #0f1625;
        --input-border: #2c3650;
        --preview-bg: #141c2b;
        --toast-bg: #1b2538;
        --toast-fg: #e6edf7;
        --danger: #ff6b6b;
      }
      body {
        font-family: system-ui, sans-serif;
        max-width: 58rem;
        margin: 1.5rem auto;
        padding: 0 1.25rem 3rem;
        background: var(--bg);
        color: var(--fg);
      }
      fieldset {
        margin-bottom: 2rem;
        padding: 1.2rem;
        border: 1px solid var(--panel-border);
        border-radius: 0.75rem;
        background: var(--panel);
        box-shadow: 0 1.2rem 2.5rem rgba(0, 0, 0, 0.25);
      }
      legend {
        color: var(--fg);
      }
      .preview {
        max-width: 100%;
        border: 1px solid var(--input-border);
        margin: 0.5rem 0;
        display: block; /* Ensure it behaves like a block for layout */
        background-color: var(--preview-bg); /* Indicate loading/empty state */
        min-height: 50px; /* Prevent collapse when empty */
      }
      .gallery {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 0.75rem;
      }
      .gallery img {
        width: 100%;
        border: 1px solid var(--input-border);
        border-radius: 0.4rem;
        background: var(--preview-bg);
      }
      small {
        opacity: 0.78;
        color: var(--muted);
      }
      a {
        color: var(--accent);
      }
      a:hover {
        color: var(--accent-hover);
      }
      input,
      select,
      textarea,
      button {
        font: inherit;
      }
      input[type="text"],
      input[type="number"],
      input[type="file"],
      input[type="email"],
      input[type="password"],
      select,
      textarea {
        background: var(--input-bg);
        color: var(--fg);
        border: 1px solid var(--input-border);
        border-radius: 0.45rem;
        padding: 0.45rem 0.6rem;
      }
      textarea {
        resize: vertical;
      }
      textarea::placeholder,
      input::placeholder {
        color: var(--muted);
      }
      input:focus,
      select:focus,
      textarea:focus {
        outline: 3px solid rgba(79, 140, 255, 0.25);
        border-color: var(--accent);
      }
      input[type="range"],
      input[type="checkbox"],
      input[type="radio"] {
        background: transparent;
        border-radius: 0;
        padding: 0;
      }
      /* toast */
      #toast {
        position: fixed;
        bottom: 1.5rem;
        right: 1rem;
        background: var(--toast-bg);
        color: var(--toast-fg);
        padding: 0.75rem 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        display: none;
        max-width: 22rem;
        z-index: 1000; /* Ensure toast is on top */
      }
      #toast button {
        background: transparent;
        border: none;
        color: inherit;
        font-size: 1rem;
        padding: 0;
        margin-left: 0.5rem;
        cursor: pointer;
        box-shadow: none;
        transform: none;
      }
      #toast button:hover,
      #toast button:active {
        background: transparent;
        box-shadow: none;
        transform: none;
      }
      .error-panel {
        margin-top: 0.85rem;
        border: 1px solid var(--danger);
        background: rgba(255, 107, 107, 0.1);
        border-radius: 0.6rem;
        padding: 0.6rem 0.75rem;
      }
      .error-panel strong {
        color: var(--danger);
      }
      .error-panel pre {
        margin: 0.4rem 0 0;
        white-space: pre-wrap;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 0.85rem;
        color: var(--fg);
      }
      /* spinner */
      .spinner {
        width: 18px;
        height: 18px;
        border: 3px solid rgba(79, 140, 255, 0.25);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        display: inline-block;
        vertical-align: middle;
        margin-left: 0.4rem;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      /* mask & out‑paint */
      .mask-container {
        position: relative;
        display: inline-block; /* Adjust as needed, inline-block allows text flow */
        margin-top: 0.5rem;
        max-width: 100%; /* Ensure container doesn't overflow */
        line-height: 0; /* Prevent extra space below image */
      }
      .mask-container img {
        max-width: 100%; /* Image scales down */
        display: block; /* Prevents bottom space */
        /* vertical-align: top; Align canvases */
      }
      .mask-canvas {
        position: absolute;
        top: 0;
        left: 0;
        cursor: crosshair;
        opacity: 0.55; /* Make mask semi-transparent */
        /* width/height set by JS */
      }
      .tools {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
        margin: 0.5rem 0;
      }
      .outpaint-panel {
        border: 1px dashed var(--input-border);
        border-radius: 0.6rem;
        padding: 0.75rem;
        background: rgba(15, 22, 37, 0.65);
      }
      .outpaint-frame {
        position: relative;
        border: 1px dashed var(--input-border);
        border-radius: 0.6rem;
        background-color: var(--preview-bg);
        background-image: linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.06) 25%,
            transparent 25%
          ),
          linear-gradient(-45deg, rgba(255, 255, 255, 0.06) 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, rgba(255, 255, 255, 0.06) 75%),
          linear-gradient(-45deg, transparent 75%, rgba(255, 255, 255, 0.06) 75%);
        background-size: 18px 18px;
        background-position: 0 0, 0 9px, 9px -9px, -9px 0px;
        overflow: hidden;
        min-height: 200px;
        margin-top: 0.5rem;
      }
      .outpaint-frame.empty::after {
        content: "Select Image 1 to place it here.";
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        color: var(--muted);
        font-size: 0.9rem;
      }
      .outpaint-image {
        position: absolute;
        top: 0;
        left: 0;
        cursor: grab;
        user-select: none;
        touch-action: none;
        border: 1px solid var(--input-border);
        background: var(--preview-bg);
      }
      .outpaint-image.dragging {
        cursor: grabbing;
      }
      .outpaint-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem 1.2rem;
        margin-top: 0.6rem;
        color: var(--muted);
        font-size: 0.85rem;
      }
      .outpaint-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.6rem;
      }
      .image-input-row {
        margin-bottom: 0.4rem;
      }
      .dimmed {
        opacity: 0.4;
        pointer-events: none;
      }
      /* Hide file inputs visually but keep them accessible */
      input[type="file"] {
        /* Add some spacing */
        margin-top: 5px;
      }
      /* Style labels for better alignment */
      label {
        display: inline-block;
        margin-right: 1em;
        margin-bottom: 0.5em;
      }
      #imgInputs label {
        display: block; /* Each image input on a new line */
      }
      textarea {
        box-sizing: border-box; /* Include padding/border in width */
        vertical-align: top; /* Align with labels */
        margin-bottom: 0.5em;
      }
      button {
        padding: 0.55em 1.1em;
        cursor: pointer;
        background: var(--accent);
        color: #091123;
        border: none;
        border-radius: 0.6rem;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }
      button:hover {
        background: var(--accent-hover);
        box-shadow: 0 0.8rem 1.6rem rgba(79, 140, 255, 0.25);
        transform: translateY(-1px);
      }
      button:active {
        background: var(--accent-active);
        transform: translateY(0);
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      select,
      input[type="number"],
      input[type="range"] {
        margin-right: 0.5em;
        vertical-align: middle;
      }
      input[type="range"] {
        vertical-align: middle;
      }

      /* --- Prompt Textarea Styling --- */
      /* Make the labels containing the prompts behave as blocks */
      label[for="gPrompt"],
      label[for="ePrompt"] {
        display: block; /* Take full available width */
        margin-right: 0; /* Override general label margin if needed */
      }

      /* Ensure the textareas fill their block-level labels */
      #gPrompt,
      #ePrompt {
        width: 100%;
        /* box-sizing: border-box; is already in the general textarea rule, which is good */
        margin-top: 0.25em; /* Optional: add space below the "Prompt" text */
        /* vertical-align: top; is also inherited */
      }
      /* --- End Prompt Textarea Styling --- */
    </style>
  </head>
  <body>
    <h1>OpenAI Image‑API Playground</h1>

    <!-- Toast notification -->
    <div id="toast">
      <span id="toastMsg"></span><button id="toastClose">✕</button>
    </div>

    <!-- ============  GENERATE  ============ -->
    <fieldset>
      <legend><strong>Generate images</strong></legend>
      <label for="gPrompt"
        >Prompt<br /><textarea id="gPrompt" rows="5"></textarea></label
      ><br />

      <label for="gN"
        >Number
        <input
          type="number"
          id="gN"
          min="1"
          max="8"
          value="1"
          style="width: 4rem"
      /></label>
      <label for="gSize"
        >Size
        <select id="gSize">
          <option value="auto">auto</option>
          <option>1024x1024</option>
          <option>1536x1024</option>
          <option>1024x1536</option>
        </select></label
      >
      <label for="gQual"
        >Quality
        <select id="gQual">
          <option value="auto">auto</option>
          <option>low</option>
          <option>medium</option>
          <option>high</option>
        </select></label
      >
      <label for="gFmt"
        >Format
        <select id="gFmt">
          <option>png</option>
          <option>jpeg</option>
          <option>webp</option>
        </select></label
      >
      <label for="gComp"
        >Compression (<span id="gCompVal">100</span>)
        <input type="range" id="gComp" min="0" max="100" value="100"
      /></label>
      <label for="gBg"
        >Background
        <select id="gBg">
          <option value="">opaque</option>
          <option value="transparent">transparent</option>
        </select></label
      >
      <label for="gMod"
        >Moderation
        <select id="gMod">
          <option value="auto">auto</option>
          <option>low</option>
        </select></label
      >

      <br /><button id="gBtn">Generate</button> <span id="gSpin"></span>
      <div id="gallery" class="gallery"></div>
      <div id="gError" class="error-panel" style="display: none">
        <strong>Generate error</strong>
        <pre id="gErrorText"></pre>
      </div>
    </fieldset>

    <!-- ============  EDIT / COMBINE / OUT‑PAINT  ============ -->
    <fieldset id="editFs">
      <legend><strong>Edit / Combine / Out‑paint</strong></legend>
      <label for="ePrompt"
        >Prompt<br /><textarea id="ePrompt" rows="5"></textarea></label
      ><br />

      <label
        ><input type="checkbox" id="useOutpaint" /> Outpaint with mask</label
      >
      <small id="outpaintHint"
        >Requires exactly one image and a fixed canvas size.</small
      ><br />

      <label><input type="checkbox" id="useMask" /> Use in‑painting mask</label
      ><br />

      <div id="imgInputs">
        <div class="image-input-row">
          <label for="image1"
            >Image 1
            <input
              type="file"
              name="image1"
              id="image1"
              accept="image/*" /></label
          >
        </div>
      </div>
      <button id="addImg" type="button">+ add image</button>
      <small id="imgLimitNote">(max 10)</small><br /><br />

      <div id="outpaintSection" style="display: none">
        <div class="outpaint-panel">
          <div class="outpaint-frame" id="outpaintFrame">
            <img
              id="outpaintImg"
              class="outpaint-image"
              alt="Outpaint placement preview"
            />
          </div>
          <div class="outpaint-meta">
            <span id="outpaintCanvasMeta">Canvas: -</span>
            <span id="outpaintImageMeta">Image: -</span>
            <span id="outpaintPosMeta">Position: -</span>
            <span id="outpaintFitMeta">Fit: -</span>
          </div>
          <div class="outpaint-actions">
            <button id="outpaintCenter" type="button">Center</button>
            <button id="outpaintTopLeft" type="button">Top-left</button>
          </div>
          <small id="outpaintSizeNote" style="display: none"
            >Select a fixed canvas size for outpainting.</small
          >
        </div>
      </div>

      <!-- Mask tools (hidden unless #useMask is checked) -->
      <div id="maskSection" style="display: none">
        <div class="mask-container">
          <img id="baseImg" class="preview" alt="reference for mask" />
          <canvas id="maskCanvas" class="mask-canvas"></canvas>
          <canvas
            id="rectPreview"
            class="mask-canvas"
            style="pointer-events: none; display: none"
          ></canvas>
          <!-- Initially hidden -->
        </div>

        <div class="tools">
          <label for="brushSize"
            >Brush Size
            <input type="range" id="brushSize" min="5" max="120" value="40"
          /></label>
          <label
            ><input type="radio" name="tool" value="brush" checked /> Erase
            (Mask)</label
          >
          <label
            ><input type="radio" name="tool" value="erase" /> Restore
            (Unmask)</label
          >
          <label
            ><input type="radio" name="tool" value="rect" /> Rect Erase</label
          >
          <label
            ><input type="checkbox" id="showMask" checked /> Show mask
            overlay</label
          >
          <button id="resetMask" type="button">Reset mask</button>
        </div>

      </div>

      <hr style="margin: 1.5rem 0" />
      <!-- Separator -->

      <label for="eN"
        >Number (if supported)
        <input
          type="number"
          id="eN"
          min="1"
          max="8"
          value="1"
          style="width: 4rem"
      /></label>
      <label for="eSize"
        >Size
        <select id="eSize">
          <option value="auto">auto</option>
          <option>1024x1024</option>
          <option>1536x1024</option>
          <option>1024x1536</option>
        </select></label
      >
      <label for="eQual"
        >Quality
        <select id="eQual">
          <option value="auto">auto</option>
          <option>low</option>
          <option>medium</option>
          <option>high</option>
        </select></label
      >
      <!-- Removed Format, Compression, Moderation as they are not standard for Edit API -->
      <label for="eBg"
        >Background
        <select id="eBg">
          <option value="">opaque</option>
          <option value="transparent">transparent</option>
        </select></label
      >

      <br /><button id="eBtn">Create Edit</button> <span id="eSpin"></span>
      <div style="margin-top: 1rem">
        <a id="eLink" class="meta" target="_blank" style="display: none"></a>
        <img
          id="eImg"
          class="preview"
          style="display: none"
          alt="Edited image result"
        />
        <div id="eGallery" class="gallery" style="display: none"></div>
      </div>
      <div id="eError" class="error-panel" style="display: none">
        <strong>Edit error</strong>
        <pre id="eErrorText"></pre>
      </div>
    </fieldset>

    <script>
      const $ = (q) => document.querySelector(q);
      const $$ = (q) => document.querySelectorAll(q);
      const OUTPAINT_SIZES = {
        "1024x1024": { w: 1024, h: 1024 },
        "1536x1024": { w: 1536, h: 1024 },
        "1024x1536": { w: 1024, h: 1536 },
      };

      /* ---------- toast helpers ---------- */
      let toastTimeout;
      function showToast(msg, duration = 4000) {
        clearTimeout(toastTimeout);
        $("#toastMsg").textContent = msg;
        $("#toast").style.display = "block";
        toastTimeout = setTimeout(() => {
          $("#toast").style.display = "none";
        }, duration);
      }
      $("#toastClose").onclick = () => {
        clearTimeout(toastTimeout);
        $("#toast").style.display = "none";
      };

      /* ---------- helpers ---------- */
      function setError(panelSel, textSel, message) {
        const panel = $(panelSel);
        const text = $(textSel);
        if (!panel || !text) return;
        if (!message) {
          text.textContent = "";
          panel.style.display = "none";
          return;
        }
        text.textContent =
          typeof message === "string"
            ? message
            : JSON.stringify(message, null, 2);
        panel.style.display = "block";
      }
      function normaliseName(n) {
        const nameLower = n.toLowerCase();
        return nameLower.endsWith(".jpg")
          ? nameLower.replace(/\.jpg$/, ".jpeg")
          : nameLower;
      }
      async function post(url, fd) {
        // Log FormData contents for debugging
        // console.log(`Posting to ${url}:`);
        // for (let [key, value] of fd.entries()) {
        //     console.log(`  ${key}:`, value instanceof File ? `${value.name} (${value.size} bytes, type: ${value.type})` : value);
        // }
        try {
          const r = await fetch(url, { method: "POST", body: fd });
          // Check for non-JSON error responses (like HTML for 404 or 500)
          if (!r.ok) {
            const errorText = await r.text();
            console.error("Server Error Response:", errorText);
            // Try to parse as JSON, fallback to text
            try {
              const errorJson = JSON.parse(errorText);
              return {
                ok: false,
                error: errorJson.error || `HTTP ${r.status}: ${r.statusText}`,
              };
            } catch {
              return {
                ok: false,
                error: `HTTP ${r.status}: ${
                  r.statusText
                }. Response: ${errorText.substring(0, 100)}...`,
              };
            }
          }
          // Check content type before parsing JSON
          const contentType = r.headers.get("content-type");
          if (contentType && contentType.includes("application/json")) {
            return r.json(); // Parse JSON response
          } else {
            const responseText = await r.text();
            console.warn("Received non-JSON response:", responseText);
            return {
              ok: false,
              error: `Unexpected response format: ${contentType}`,
            };
          }
        } catch (networkError) {
          console.error(`Network error during fetch to ${url}:`, networkError);
          return { ok: false, error: `Network error: ${networkError.message}` };
        }
      }

      function enforceCompression(fmtSel, slider, span, bgSel) {
        const sync = () => {
          const isPng = fmtSel.value === "png";
          const isJpeg = fmtSel.value === "jpeg";

          // Compression slider only relevant for non-PNG (jpeg, webp)
          slider.disabled = isPng;
          if (slider.disabled) slider.value = 100; // Reset PNG compression visually
          span.textContent = slider.value;

          // Background transparency only relevant for PNG/WEBP
          if (bgSel) {
            bgSel.disabled = isJpeg;
            if (isJpeg) bgSel.value = ""; // Force opaque for JPEG
            // Ensure transparent option is disabled if format doesn't support it
            const transparentOption = bgSel.querySelector(
              'option[value="transparent"]'
            );
            if (transparentOption) transparentOption.disabled = isJpeg;
          }
        };
        fmtSel.onchange = sync;
        slider.oninput = () => (span.textContent = slider.value);
        sync(); // Initial setup
      }

      /* ---------- compression locks ---------- */
      // Generate section
      enforceCompression($("#gFmt"), $("#gComp"), $("#gCompVal"), $("#gBg"));
      // Edit section (only background needs checking as format/compression removed)
      const eBgSel = $("#eBg");
      if (eBgSel) {
        // If we ever re-add format selection to Edit, re-enable full enforceCompression
        // For now, just ensure transparent isn't selected if backend implies JPEG (e.g., based on input)
        // This is tricky without knowing the output format beforehand for Edit.
        // Let's assume PNG/WEBP are possible if transparent is chosen.
      }

      /* ---------- dynamic image inputs ---------- */
      let imgCount = 1;
      $("#addImg").onclick = () => {
        if (imgCount >= 10) {
          showToast("Maximum of 10 images allowed.");
          return;
        }
        imgCount++;
        const row = document.createElement("div");
        row.className = "image-input-row";
        const lbl = document.createElement("label");
        const inputId = `image${imgCount}`;
        lbl.setAttribute("for", inputId);
        lbl.innerHTML = `Image ${imgCount} <input type="file" name="${inputId}" id="${inputId}" accept="image/*">`;
        row.append(lbl);
        $("#imgInputs").append(row);
      };

      /* ---------- spinner helpers ---------- */
      function startSpinner(id) {
        $(id).innerHTML = '<span class="spinner"></span>';
      }
      function stopSpinner(id) {
        $(id).innerHTML = "";
      }
      function disable(el, on = true) {
        if (!el) return;
        el.classList.toggle("dimmed", on);
        el.disabled = on;
      }

      /* ---------- GENERATE ---------- */
      $("#gBtn").onclick = async () => {
        const prompt = $("#gPrompt").value.trim();
        if (!prompt) {
          showToast("Prompt is required for generation.");
          setError("#gError", "#gErrorText", "Prompt is required.");
          return;
        }
        disable($("#gBtn"));
        startSpinner("#gSpin");
        $("#gallery").innerHTML = ""; // Clear previous results
        setError("#gError", "#gErrorText", "");

        const fd = new FormData();
        fd.append("prompt", prompt);
        fd.append("n", $("#gN").value);
        [
          "size",
          "quality",
          "output_format",
          "output_compression",
          "background",
          "moderation",
        ].forEach((k) => {
          const el = $(
            `#g${
              k.charAt(0).toUpperCase() +
              k
                .slice(1)
                .replace(/_[a-z]/g, (m) => m[1].toUpperCase())
                .replace("Output_f", "F")
                .replace("Output_c", "C")
                .replace("oderation", "Mod")
                .replace("uality", "Qual")
                .replace("ize", "Size")
                .replace("ackground", "Bg")
            }`
          ); // Map k to element ID
          if (el && el.value !== "auto" && el.value !== "") {
            fd.append(k, el.value);
          }
        });

        // Handle background=transparent validation client-side
        if (
          fd.get("background") === "transparent" &&
          !["png", "webp"].includes(fd.get("output_format"))
        ) {
          showToast("Transparent background requires PNG or WEBP format.");
          setError(
            "#gError",
            "#gErrorText",
            "Transparent background requires PNG or WEBP format."
          );
          stopSpinner("#gSpin");
          disable($("#gBtn"), false);
          return;
        }

        const res = await post("/generate", fd);
        stopSpinner("#gSpin");
        disable($("#gBtn"), false);

        if (!res || !res.ok) {
          showToast(
            res?.error || "Generate failed. Check console for details."
          );
          setError(
            "#gError",
            "#gErrorText",
            res?.error || "Generate failed."
          );
          return;
        }
        if (!res.data_uris || res.data_uris.length === 0) {
          showToast("Received OK response but no images were returned.");
          setError(
            "#gError",
            "#gErrorText",
            "Received OK response but no images were returned."
          );
          return;
        }
        setError("#gError", "#gErrorText", "");

        res.data_uris.forEach((uri, i) => {
          const img = new Image();
          img.src = uri;
          img.title = `Generated Image ${i + 1}`;
          img.className = "preview";
          img.alt = `Generated image ${i + 1} for prompt: ${prompt.substring(
            0,
            50
          )}...`;
          $("#gallery").append(img);
        });
      };

      const editFs = $("#editFs");
      const outpaintToggle = $("#useOutpaint"),
        outpaintSection = $("#outpaintSection"),
        outpaintFrame = $("#outpaintFrame"),
        outpaintImg = $("#outpaintImg"),
        outpaintCanvasMeta = $("#outpaintCanvasMeta"),
        outpaintImageMeta = $("#outpaintImageMeta"),
        outpaintPosMeta = $("#outpaintPosMeta"),
        outpaintFitMeta = $("#outpaintFitMeta"),
        outpaintCenter = $("#outpaintCenter"),
        outpaintTopLeft = $("#outpaintTopLeft"),
        outpaintSizeNote = $("#outpaintSizeNote");

      /* ---------- Mask UI toggle ---------- */
      $("#useMask").onchange = (e) => {
        if (outpaintEnabled) {
          e.target.checked = false;
          showToast("Disable outpainting to use the manual mask.");
          return;
        }
        const show = e.target.checked;
        $("#maskSection").style.display = show ? "block" : "none";
        // Ensure an image is loaded and has rendered dimensions before resizing
        if (
          show &&
          baseImg.src &&
          baseImg.clientWidth > 0 &&
          baseImg.clientHeight > 0
        ) {
          // Call resizeCanvases which now uses natural dimensions for bitmap
          resizeCanvases();
        } else if (show && !baseImg.src) {
          showToast("Please select 'Image 1' to use the mask feature.");
          e.target.checked = false; // Uncheck the box
          $("#maskSection").style.display = "none";
        }
      };

      /* ---------- Mask drawing logic ---------- */
      const maskSect = $("#maskSection"),
        baseImg = $("#baseImg"),
        maskCan = $("#maskCanvas"),
        rectCan = $("#rectPreview"), // Preview canvas for rectangle tool
        ctxMask = maskCan.getContext("2d", { willReadFrequently: true }), // Added willReadFrequently for potential performance
        ctxRect = rectCan.getContext("2d");

      let drawing = false,
        startX = 0,
        startY = 0,
        naturalW = 0, // Natural dimensions of the base image
        naturalH = 0,
        outpaintEnabled = false,
        outpaintDragging = false,
        outpaintPosX = 0,
        outpaintPosY = 0,
        outpaintScale = 1,
        outpaintStartX = 0,
        outpaintStartY = 0,
        outpaintStartPosX = 0,
        outpaintStartPosY = 0;

      function resizeCanvases() {
        // Get rendered dimensions (size on screen)
        const renderedW = baseImg.clientWidth;
        const renderedH = baseImg.clientHeight;

        // Check for valid dimensions
        if (!naturalW || !naturalH || !renderedW || !renderedH) {
          // console.warn("Cannot resize canvases: Dimensions not available.", {naturalW, naturalH, renderedW, renderedH});
          // Optionally clear canvases if dimensions are invalid
          [maskCan, rectCan].forEach((c) => {
            c.width = 0;
            c.height = 0;
            c.style.width = "0px";
            c.style.height = "0px";
          });
          return;
        }

        // Set bitmap dimensions to natural image size
        maskCan.width = naturalW;
        maskCan.height = naturalH;
        rectCan.width = naturalW;
        rectCan.height = naturalH;

        // Set CSS dimensions to match the rendered image size
        maskCan.style.width = renderedW + "px";
        maskCan.style.height = renderedH + "px";
        rectCan.style.width = renderedW + "px";
        rectCan.style.height = renderedH + "px";

        // console.log(`Resized canvases: Bitmap=${naturalW}x${naturalH}, CSS=${renderedW}x${renderedH}`);

        // Reset drawing state after resize - fill mask completely black (meaning nothing is masked initially)
        resetMask(true); // Full reset to black
      }

      function resetMask(full = true) {
        if (!naturalW || !naturalH) return; // Don't reset if no dimensions

        // Clear both canvases
        ctxMask.clearRect(0, 0, naturalW, naturalH);
        ctxRect.clearRect(0, 0, naturalW, naturalH);

        if (full) {
          // Set composite mode to default for filling
          ctxMask.globalCompositeOperation = "source-over";
          // Fill the mask canvas with black (representing the original image area, not masked)
          ctxMask.fillStyle = "black";
          ctxMask.fillRect(0, 0, naturalW, naturalH);
          // Set composite mode for erasing (drawing transparency)
          ctxMask.globalCompositeOperation = "destination-out";
        } else {
          // If not a full reset (e.g., after outpainting), just clear to transparent
          // and set mode for drawing the mask (black)
          ctxMask.globalCompositeOperation = "source-over";
        }
      }

      function tool() {
        const selectedTool = document.querySelector(
          'input[name="tool"]:checked'
        );
        return selectedTool ? selectedTool.value : "brush"; // Default to brush
      }

      // Calculate mouse position relative to the canvas bitmap (natural dimensions)
      function pos(e) {
        const r = maskCan.getBoundingClientRect(); // Canvas position and rendered size
        const renderedW = r.width;
        const renderedH = r.height;

        // Prevent division by zero if canvas isn't rendered
        if (!renderedW || !renderedH || !naturalW || !naturalH) {
          return { x: 0, y: 0 };
        }

        // Click position relative to the viewport
        const clientX = e.clientX;
        const clientY = e.clientY;

        // Click position relative to the rendered canvas element
        const canvasX = clientX - r.left;
        const canvasY = clientY - r.top;

        // Scale coordinates from rendered size to natural bitmap size
        const scaleX = naturalW / renderedW;
        const scaleY = naturalH / renderedH;

        return {
          x: canvasX * scaleX,
          y: canvasY * scaleY,
        };
      }

      // --- MASK DRAWING EVENT LISTENERS ---

      maskCan.addEventListener("mousedown", (e) => {
        if (!naturalW || !naturalH) return; // Ensure image/canvas is ready
        drawing = true;
        ({ x: startX, y: startY } = pos(e)); // Get starting position (scaled)

        const currentTool = tool();
        const brushSize = +$("#brushSize").value;

        if (currentTool === "rect") {
          // Using rectangle tool - prepare the preview canvas
          ctxRect.clearRect(0, 0, naturalW, naturalH); // Clear previous rect preview
          // Style the preview rectangle
          ctxRect.setLineDash([6 * (naturalW / (baseImg.clientWidth || 1))]); // Scale dash pattern roughly
          ctxRect.strokeStyle = "rgba(255, 0, 0, 0.8)"; // Red preview line
          ctxRect.lineWidth = 2 * (naturalW / (baseImg.clientWidth || 1)); // Scale line width roughly
        } else {
          // Using brush or erase tool - prepare the main mask canvas
          ctxMask.lineCap = "round";
          ctxMask.lineJoin = "round";
          ctxMask.lineWidth = brushSize;

          // Set the drawing mode:
          // 'destination-out': Erases (makes transparent) where you draw. For the 'brush' (Erase Mask) tool.
          // 'source-over': Draws normally (black). For the 'erase' (Restore Unmask) tool.
          ctxMask.globalCompositeOperation =
            currentTool === "erase" ? "source-over" : "destination-out";

          ctxMask.beginPath();
          ctxMask.moveTo(startX, startY);
          // Draw a dot for single clicks
          ctxMask.lineTo(startX + 0.1, startY + 0.1); // Tiny line to make a dot
          ctxMask.stroke();
          ctxMask.beginPath(); // Start a new path for potential dragging
          ctxMask.moveTo(startX, startY);
        }
      });

      maskCan.addEventListener("mousemove", (e) => {
        if (!drawing || !naturalW || !naturalH) return;
        const { x, y } = pos(e); // Get current position (scaled)
        const currentTool = tool();

        if (currentTool === "rect") {
          // Update the preview rectangle on the rectCanvas
          ctxRect.clearRect(0, 0, naturalW, naturalH); // Clear previous preview
          ctxRect.strokeRect(startX, startY, x - startX, y - startY); // Draw new preview
        } else {
          // Continue drawing the line on the main maskCanvas
          ctxMask.lineTo(x, y);
          ctxMask.stroke();
        }
      });

      maskCan.addEventListener("mouseup", (e) => {
        if (!drawing || !naturalW || !naturalH) return;
        drawing = false;
        const { x: endX, y: endY } = pos(e); // Get end position (scaled)
        const currentTool = tool();

        if (currentTool === "rect") {
          // Apply the rectangle to the main maskCanvas
          const x = Math.min(startX, endX);
          const y = Math.min(startY, endY);
          const w = Math.abs(endX - startX);
          const h = Math.abs(endY - startY);

          // Use 'destination-out' to erase the rectangle area
          ctxMask.globalCompositeOperation = "destination-out";
          ctxMask.fillRect(x, y, w, h);

          // Clear the preview rectangle canvas
          ctxRect.clearRect(0, 0, naturalW, naturalH);
        } else {
          // Finish the line for brush/erase
          ctxMask.lineTo(endX, endY);
          ctxMask.stroke();
        }

        // Reset the path and prepare for next erase operation
        ctxMask.beginPath();
        // IMPORTANT: Set composite op back to destination-out for subsequent brush strokes
        // unless the tool is 'erase' (restore)
        ctxMask.globalCompositeOperation =
          tool() === "erase" ? "source-over" : "destination-out";
      });

      maskCan.addEventListener("mouseleave", (e) => {
        // Stop drawing if mouse leaves canvas while button is pressed
        if (drawing) {
          drawing = false;
          const currentTool = tool();
          if (currentTool !== "rect") {
            ctxMask.stroke(); // Finish current line segment
            ctxMask.beginPath(); // Reset path
          } else {
            // Optionally clear rect preview if mouse leaves? Or apply rect?
            // Let's clear it for now.
            ctxRect.clearRect(0, 0, naturalW, naturalH);
          }
          // Reset composite op
          ctxMask.globalCompositeOperation =
            tool() === "erase" ? "source-over" : "destination-out";
        }
      });

      // --- MASK UI CONTROLS ---

      $("#showMask").onchange = (e) => {
        const show = e.target.checked;
        maskCan.style.opacity = show ? "0.55" : "0"; // Toggle visibility via opacity
        // Hide rect preview if mask is hidden
        rectCan.style.display = show && tool() === "rect" ? "block" : "none";
      };

      $("#resetMask").onclick = () => {
        resetMask(true); // Full reset to black, ready for erasing
        showToast("Mask reset.");
      };

      // Update rectCanvas visibility and mask composite operation when tool changes
      editFs.addEventListener("change", (e) => {
        if (e.target.name === "tool") {
          const currentTool = e.target.value;
          rectCan.style.display =
            currentTool === "rect" && $("#showMask").checked ? "block" : "none";
          // Set composite operation for next drawing action
          ctxMask.globalCompositeOperation =
            currentTool === "erase" ? "source-over" : "destination-out";
          // Reset current path to avoid connecting lines between tool changes
          ctxMask.beginPath();
        }
      });

      // --- IMAGE LOADING AND HANDLING ---

      $("#imgInputs").addEventListener("change", (e) => {
        // Only react to changes in the *first* image input for the mask base
        if (e.target.name !== "image1") return;

        const f = e.target.files[0];
        if (!f) {
          // Clear image and reset canvas if file is removed
          baseImg.src = "#"; // Use # or empty string to clear
          baseImg.alt = "reference for mask";
          naturalW = 0;
          naturalH = 0;
          outpaintPosX = 0;
          outpaintPosY = 0;
          if (outpaintImg) {
            outpaintImg.removeAttribute("src");
            outpaintImg.alt = "Outpaint placement preview";
          }
          resizeCanvases(); // Clear canvases visually
          updateOutpaintPreview();
          $("#maskSection").style.display = "none"; // Hide mask section
          $("#useMask").checked = false; // Uncheck mask checkbox
          return;
        }

        // Validate file type (basic check)
        if (!f.type.startsWith("image/")) {
          showToast("Please select a valid image file (PNG, JPEG, WEBP, GIF).");
          e.target.value = ""; // Clear the invalid file selection
          return;
        }

        const R = new FileReader();
        R.onload = (ev) => {
          baseImg.src = ev.target.result;
          baseImg.alt = `Mask base: ${f.name}`;
          if (outpaintImg) {
            outpaintImg.src = ev.target.result;
            outpaintImg.alt = `Outpaint source: ${f.name}`;
          }
          // The baseImg.onload event will handle resizing and setting natural dimensions
          // Show mask section immediately if checkbox is already checked
          if ($("#useMask").checked) {
            $("#maskSection").style.display = "block";
          }
        };
        R.onerror = (err) => {
          console.error("FileReader error:", err);
          showToast("Error reading file.");
          baseImg.src = "#"; // Clear image on error
          naturalW = 0;
          naturalH = 0;
          updateOutpaintPreview();
        };
        R.readAsDataURL(f);
      });

      // IMPORTANT: This runs *after* a new image is loaded into baseImg.src
      baseImg.onload = () => {
        // Check if the src is valid (not '#' or empty)
        if (
          !baseImg.currentSrc ||
          baseImg.currentSrc === window.location.href + "#"
        ) {
          // console.log("baseImg onload triggered for empty src, skipping resize.");
          return;
        }

        // Store natural dimensions from the loaded image
        naturalW = baseImg.naturalWidth;
        naturalH = baseImg.naturalHeight;

        // console.log(`baseImg loaded: Natural dimensions ${naturalW}x${naturalH}`);

        // Now resize canvases using the new natural dimensions
        resizeCanvases();

        // If the mask section should be visible (checkbox checked), ensure it is
        if (!outpaintEnabled && $("#useMask").checked) {
          $("#maskSection").style.display = "block";
        }
        if (outpaintEnabled) {
          centerOutpaintImage();
        } else {
          updateOutpaintPreview();
        }
      };
      baseImg.onerror = () => {
        showToast("Error loading image into preview.");
        baseImg.alt = "Image load error";
        naturalW = 0;
        naturalH = 0;
        resizeCanvases(); // Clear canvases
        updateOutpaintPreview();
      };

      /* ---------- Outpaint placement ---------- */
      function parseOutpaintSize(value) {
        const size = OUTPAINT_SIZES[value];
        return size ? { w: size.w, h: size.h } : null;
      }

      function getOutpaintSize() {
        return parseOutpaintSize($("#eSize").value);
      }

      function outpaintFits(size) {
        return (
          size &&
          naturalW &&
          naturalH &&
          naturalW <= size.w &&
          naturalH <= size.h
        );
      }

      function clampOutpaintPosition() {
        const size = getOutpaintSize();
        if (!size || !naturalW || !naturalH) return;
        const maxX = Math.max(0, size.w - naturalW);
        const maxY = Math.max(0, size.h - naturalH);
        outpaintPosX = Math.min(Math.max(outpaintPosX, 0), maxX);
        outpaintPosY = Math.min(Math.max(outpaintPosY, 0), maxY);
      }

      function setOutpaintPosition(x, y) {
        outpaintPosX = Math.round(x);
        outpaintPosY = Math.round(y);
        clampOutpaintPosition();
        updateOutpaintPreview();
      }

      function centerOutpaintImage() {
        const size = getOutpaintSize();
        if (!size || !naturalW || !naturalH) return;
        outpaintPosX = Math.max(0, Math.round((size.w - naturalW) / 2));
        outpaintPosY = Math.max(0, Math.round((size.h - naturalH) / 2));
        clampOutpaintPosition();
        updateOutpaintPreview();
      }

      function updateOutpaintPreview() {
        if (!outpaintSection || !outpaintFrame) return;
        if (!outpaintEnabled) {
          outpaintSection.style.display = "none";
          return;
        }
        outpaintSection.style.display = "block";
        const size = getOutpaintSize();
        if (!size) {
          if (outpaintSizeNote) outpaintSizeNote.style.display = "block";
          outpaintFrame.classList.add("empty");
          outpaintFrame.style.width = "100%";
          outpaintFrame.style.height = "220px";
          if (outpaintCanvasMeta) outpaintCanvasMeta.textContent = "Canvas: -";
          if (outpaintImageMeta) outpaintImageMeta.textContent = "Image: -";
          if (outpaintPosMeta) outpaintPosMeta.textContent = "Position: -";
          if (outpaintFitMeta) outpaintFitMeta.textContent = "Fit: -";
          if (outpaintImg) outpaintImg.style.display = "none";
          return;
        }
        if (outpaintSizeNote) outpaintSizeNote.style.display = "none";
        const containerWidth = outpaintFrame.parentElement
          ? outpaintFrame.parentElement.clientWidth
          : 520;
        const maxPreview = Math.min(520, containerWidth || 520);
        outpaintScale = Math.min(
          maxPreview / size.w,
          maxPreview / size.h,
          1
        );
        outpaintFrame.style.width = `${size.w * outpaintScale}px`;
        outpaintFrame.style.height = `${size.h * outpaintScale}px`;
        if (!naturalW || !naturalH || !baseImg.src || baseImg.src === "#") {
          outpaintFrame.classList.add("empty");
          if (outpaintCanvasMeta)
            outpaintCanvasMeta.textContent = `Canvas: ${size.w}x${size.h}`;
          if (outpaintImageMeta) outpaintImageMeta.textContent = "Image: -";
          if (outpaintPosMeta) outpaintPosMeta.textContent = "Position: -";
          if (outpaintFitMeta) outpaintFitMeta.textContent = "Fit: -";
          if (outpaintImg) outpaintImg.style.display = "none";
          return;
        }
        outpaintFrame.classList.remove("empty");
        clampOutpaintPosition();
        if (outpaintImg) {
          outpaintImg.style.display = "block";
          outpaintImg.style.width = `${naturalW * outpaintScale}px`;
          outpaintImg.style.height = `${naturalH * outpaintScale}px`;
          outpaintImg.style.left = `${outpaintPosX * outpaintScale}px`;
          outpaintImg.style.top = `${outpaintPosY * outpaintScale}px`;
        }
        if (outpaintCanvasMeta)
          outpaintCanvasMeta.textContent = `Canvas: ${size.w}x${size.h}`;
        if (outpaintImageMeta)
          outpaintImageMeta.textContent = `Image: ${naturalW}x${naturalH}`;
        if (outpaintPosMeta)
          outpaintPosMeta.textContent = `Position: ${Math.round(
            outpaintPosX
          )}, ${Math.round(outpaintPosY)}`;
        if (outpaintFitMeta)
          outpaintFitMeta.textContent = outpaintFits(size)
            ? "Fit: ok"
            : "Fit: too large";
      }

      function setOutpaintMode(enabled) {
        outpaintEnabled = enabled;
        if (outpaintToggle) outpaintToggle.checked = enabled;
        if (outpaintSection)
          outpaintSection.style.display = enabled ? "block" : "none";
        const sizeSel = $("#eSize");
        const autoOpt = sizeSel
          ? sizeSel.querySelector('option[value="auto"]')
          : null;
        if (autoOpt) autoOpt.disabled = enabled;
        if (outpaintSizeNote)
          outpaintSizeNote.style.display =
            enabled && !getOutpaintSize() ? "block" : "none";

        const useMask = $("#useMask");
        if (useMask) {
          if (enabled) {
            useMask.checked = false;
            useMask.disabled = true;
            $("#maskSection").style.display = "none";
          } else {
            useMask.disabled = false;
          }
        }

        const addBtn = $("#addImg");
        if (addBtn) disable(addBtn, enabled);
        const imgLimit = $("#imgLimitNote");
        if (imgLimit) imgLimit.style.display = enabled ? "none" : "inline";
        $$("#imgInputs .image-input-row").forEach((row, idx) => {
          if (idx === 0) return;
          row.style.display = enabled ? "none" : "block";
          const input = row.querySelector('input[type="file"]');
          if (input) {
            input.disabled = enabled;
            if (enabled) input.value = "";
          }
        });

        if (eBgSel) eBgSel.disabled = enabled;
        if (enabled && getOutpaintSize() && naturalW && naturalH) {
          centerOutpaintImage();
        } else {
          updateOutpaintPreview();
        }
      }

      async function buildOutpaintAssets(size) {
        if (!size) {
          throw new Error("Select a fixed canvas size for outpainting.");
        }
        if (!naturalW || !naturalH || !baseImg.src || baseImg.src === "#") {
          throw new Error("Please load 'Image 1' before outpainting.");
        }
        if (!outpaintFits(size)) {
          throw new Error(
            `Image is ${naturalW}x${naturalH}. Upload a smaller image or choose a larger canvas size.`
          );
        }
        clampOutpaintPosition();

        const canvas = document.createElement("canvas");
        canvas.width = size.w;
        canvas.height = size.h;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, size.w, size.h);
        ctx.drawImage(baseImg, outpaintPosX, outpaintPosY, naturalW, naturalH);

        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = size.w;
        maskCanvas.height = size.h;
        const mctx = maskCanvas.getContext("2d");
        mctx.clearRect(0, 0, size.w, size.h);
        mctx.fillStyle = "rgba(0, 0, 0, 1)";
        mctx.fillRect(outpaintPosX, outpaintPosY, naturalW, naturalH);

        const imageBlob = await new Promise((resolve) =>
          canvas.toBlob(resolve, "image/png")
        );
        const maskBlob = await new Promise((resolve) =>
          maskCanvas.toBlob(resolve, "image/png")
        );
        if (!imageBlob || !maskBlob) {
          throw new Error("Failed to export outpaint canvas or mask.");
        }
        if (maskBlob.size >= 4000000) {
          throw new Error(
            `Mask is ${maskBlob.size} bytes. It must be under 4,000,000 bytes.`
          );
        }

        return { imageBlob, maskBlob };
      }

      if (outpaintToggle) {
        outpaintToggle.onchange = (e) => {
          setOutpaintMode(e.target.checked);
        };
      }
      $("#eSize").addEventListener("change", () => {
        if (outpaintEnabled) updateOutpaintPreview();
        if (outpaintSizeNote) {
          outpaintSizeNote.style.display =
            outpaintEnabled && !getOutpaintSize() ? "block" : "none";
        }
      });
      if (outpaintCenter) {
        outpaintCenter.onclick = () => {
          if (outpaintEnabled) centerOutpaintImage();
        };
      }
      if (outpaintTopLeft) {
        outpaintTopLeft.onclick = () => {
          if (outpaintEnabled) setOutpaintPosition(0, 0);
        };
      }
      if (outpaintImg) {
        outpaintImg.addEventListener("pointerdown", (e) => {
          if (!outpaintEnabled) return;
          const size = getOutpaintSize();
          if (!outpaintFits(size)) return;
          outpaintDragging = true;
          outpaintImg.classList.add("dragging");
          outpaintImg.setPointerCapture(e.pointerId);
          outpaintStartX = e.clientX;
          outpaintStartY = e.clientY;
          outpaintStartPosX = outpaintPosX;
          outpaintStartPosY = outpaintPosY;
        });

        outpaintImg.addEventListener("pointermove", (e) => {
          if (!outpaintDragging) return;
          const dx = (e.clientX - outpaintStartX) / outpaintScale;
          const dy = (e.clientY - outpaintStartY) / outpaintScale;
          setOutpaintPosition(outpaintStartPosX + dx, outpaintStartPosY + dy);
        });

        const stopOutpaintDrag = (e) => {
          if (!outpaintDragging) return;
          outpaintDragging = false;
          outpaintImg.classList.remove("dragging");
          try {
            outpaintImg.releasePointerCapture(e.pointerId);
          } catch (err) {
            // Ignore release errors.
          }
        };
        outpaintImg.addEventListener("pointerup", stopOutpaintDrag);
        outpaintImg.addEventListener("pointercancel", stopOutpaintDrag);
        outpaintImg.addEventListener("pointerleave", stopOutpaintDrag);
      }

      /* ---------- EDIT ---------- */
      $("#eBtn").onclick = async () => {
        const prompt = $("#ePrompt").value.trim();
        if (!prompt) {
          showToast("Prompt is required for editing.");
          setError("#eError", "#eErrorText", "Prompt is required.");
          return;
        }

        disable($("#eBtn"));
        startSpinner("#eSpin");
        $("#eImg").style.display = "none"; // Hide previous result
        $("#eLink").style.display = "none";
        $("#eGallery").style.display = "none";
        $("#eGallery").innerHTML = "";
        setError("#eError", "#eErrorText", "");

        const fd = new FormData();
        const isOutpaint = outpaintEnabled;
        const sizeVal = $("#eSize").value;
        const sizeSpec = parseOutpaintSize(sizeVal);

        fd.append("prompt", prompt);
        if (isOutpaint) {
          if (!sizeSpec) {
            showToast("Outpainting requires a fixed canvas size.");
            setError(
              "#eError",
              "#eErrorText",
              "Outpainting requires a fixed canvas size."
            );
            stopSpinner("#eSpin");
            disable($("#eBtn"), false);
            return;
          }
          fd.append("edit_mode", "outpaint");
          fd.append("size", sizeVal);
        } else if (sizeVal && sizeVal !== "auto") {
          fd.append("size", sizeVal);
        }

        const qualVal = $("#eQual").value;
        if (qualVal && qualVal !== "auto") {
          fd.append("quality", qualVal);
        }
        if (!isOutpaint) {
          const bgVal = $("#eBg").value;
          if (bgVal) {
            fd.append("background", bgVal);
          }
        }

        // Handle optional 'n' parameter (assuming backend supports it for edit)
        const nVal = $("#eN").value;
        if (nVal && parseInt(nVal, 10) >= 1) {
          fd.append("n", nVal);
        } else if (nVal !== "1") {
          // If user entered something invalid, maybe warn?
          console.warn("Ignoring invalid 'n' value for edit:", nVal);
        }
        // Note: The standard OpenAI Edit endpoint *does not* support 'n' > 1.
        // If using standard API, remove the 'n' input/logic for Edit. Keep if custom backend.

        /* --- Reference Image Handling --- */
        let refImageFile;
        let refImageName = "image.png"; // Default name

        if (isOutpaint) {
          try {
            const assets = await buildOutpaintAssets(sizeSpec);
            refImageFile = assets.imageBlob;
            fd.append("image1", assets.imageBlob, "outpaint_canvas.png");
            fd.append("mask", assets.maskBlob, "outpaint_mask.png");
            fd.append("image_w", String(naturalW));
            fd.append("image_h", String(naturalH));
            fd.append("pos_x", String(Math.round(outpaintPosX)));
            fd.append("pos_y", String(Math.round(outpaintPosY)));
            fd.append("canvas_w", String(sizeSpec.w));
            fd.append("canvas_h", String(sizeSpec.h));
          } catch (err) {
            showToast(err.message || "Outpaint preparation failed.");
            setError(
              "#eError",
              "#eErrorText",
              err.message || "Outpaint preparation failed."
            );
            stopSpinner("#eSpin");
            disable($("#eBtn"), false);
            return;
          }
        } else {
          // Find the first image input that has a file selected
          const fileInput = $("#image1"); // Directly select #image1
          if (fileInput && fileInput.files[0]) {
            refImageFile = fileInput.files[0];
            refImageName = normaliseName(refImageFile.name);
            console.log("Using file input image for edit:", refImageName);
            fd.append(fileInput.name, refImageFile, refImageName); // Use input name 'image1'
          }
          // Add other images if present (though mask usually applies only to first)
          for (let i = 2; i <= imgCount; i++) {
            const otherInput = $(`#image${i}`);
            if (otherInput && otherInput.files[0]) {
              const otherFile = otherInput.files[0];
              fd.append(
                otherInput.name,
                otherFile,
                normaliseName(otherFile.name)
              );
              console.log(`Adding additional image: ${otherInput.name}`);
            }
          }
        }

        if (!refImageFile) {
          showToast("No reference image found (select 'Image 1').");
          setError(
            "#eError",
            "#eErrorText",
            "No reference image found (select 'Image 1')."
          );
          stopSpinner("#eSpin");
          disable($("#eBtn"), false);
          return;
        }

        /* --- Mask Handling (Optional) --- */
        if (!isOutpaint && $("#useMask").checked) {
          // Ensure canvas has valid dimensions before exporting
          if (
            !maskCan ||
            maskCan.width === 0 ||
            maskCan.height === 0 ||
            !naturalW ||
            !naturalH
          ) {
            showToast(
              "Mask canvas is not ready. Ensure image is loaded and mask is enabled."
            );
            setError(
              "#eError",
              "#eErrorText",
              "Mask canvas is not ready. Ensure image is loaded and mask is enabled."
            );
            stopSpinner("#eSpin");
            disable($("#eBtn"), false);
            if (maskSect) maskSect.scrollIntoView({ behavior: "smooth" });
            return;
          }

          console.log(
            `Exporting mask with dimensions: ${maskCan.width}x${maskCan.height}`
          );
          let maskBlob;
          try {
            maskBlob = await new Promise((resolve) => {
              maskCan.toBlob(resolve, "image/png");
            });
          } catch (err) {
            console.error("maskCan.toBlob error:", err);
            maskBlob = null; // Ensure maskBlob is null on error
          }

          if (!maskBlob) {
            showToast("Mask export failed. Check console for errors.");
            setError(
              "#eError",
              "#eErrorText",
              "Mask export failed. Check console for errors."
            );
            stopSpinner("#eSpin");
            disable($("#eBtn"), false);
            if (maskSect) maskSect.scrollIntoView({ behavior: "smooth" });
            return;
          }
          console.log(`Mask blob size: ${maskBlob.size} bytes`);
          fd.append("mask", maskBlob, "mask.png");
        }

        // --- Make the API Call ---
        console.log("Sending request to /edit");
        const res = await post("/edit", fd);

        // --- Handle Response ---
        stopSpinner("#eSpin");
        disable($("#eBtn"), false);

        if (!res || !res.ok) {
          showToast(res?.error || "Edit failed. Check console for details.");
          setError("#eError", "#eErrorText", res?.error || "Edit failed.");
          // Optionally scroll to mask section if error might be related
          if (res?.error?.toLowerCase().includes("mask")) {
            if (maskSect) maskSect.scrollIntoView({ behavior: "smooth" });
          }
          return;
        }

        // --- Display Result ---
        if (Array.isArray(res.data_uris) && res.data_uris.length > 0) {
          setError("#eError", "#eErrorText", "");
          res.data_uris.forEach((uri, i) => {
            const img = new Image();
            img.src = uri;
            img.title = `Edited Image ${i + 1}`;
            img.className = "preview";
            img.alt = `Edited image ${i + 1} for prompt: ${prompt.substring(
              0,
              50
            )}...`;
            const url = res.urls && res.urls[i];
            if (url) {
              const link = document.createElement("a");
              link.href = url;
              link.target = "_blank";
              link.append(img);
              $("#eGallery").append(link);
            } else {
              $("#eGallery").append(img);
            }
          });
          $("#eGallery").style.display = "grid";
        } else if (res.data_uri && res.url) {
          $("#eImg").src = res.data_uri;
          $("#eLink").href = res.url;
          $("#eLink").textContent = `Saved copy (${res.url
            .split("/")
            .pop()}) ↗`;
          $("#eImg").style.display = "block"; // Make image visible
          $("#eLink").style.display = "inline"; // Make link visible
          $("#eImg").alt = `Edited image result for prompt: ${prompt.substring(
            0,
            50
          )}...`;
          setError("#eError", "#eErrorText", "");
        } else {
          showToast("Edit succeeded but response format is unexpected.");
          setError(
            "#eError",
            "#eErrorText",
            "Edit succeeded but response format is unexpected."
          );
          console.warn("Unexpected success response:", res);
        }
      }; // End of eBtn.onclick

      // --- Initial Page Setup ---
      function init() {
        $("#eImg").style.display = "none";
        $("#eLink").style.display = "none";
        $("#eGallery").style.display = "none";
        // Ensure mask section is hidden initially
        $("#maskSection").style.display = "none";
        // Set initial composite operation for mask
        ctxMask.globalCompositeOperation = "destination-out";
        setOutpaintMode(false);
      }

      // Run init when the DOM is fully loaded
      document.addEventListener("DOMContentLoaded", init);
      window.addEventListener("resize", () => {
        if (outpaintEnabled) updateOutpaintPreview();
      });
    </script>
  </body>
</html>
