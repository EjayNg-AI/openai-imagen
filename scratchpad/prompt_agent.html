<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Prompt Runner</title>
    <style>
      :root {
        color-scheme: dark;
        font-size: 16px;
        --bg: #080e18;
        --fg: #e7edf7;
        --panel: #111827;
        --panel-alt: #0c121f;
        --accent: #5aa9ff;
        --accent-hover: #74b8ff;
        --muted: #91a0ba;
        --border: #27344a;
        --error: #ff6b6b;
        --success: #8ff7b3;
        --textarea-bg: #0d1524;
        --textarea-border: #2b3750;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
        background: radial-gradient(circle at 20% 20%, #0f1a2a, var(--bg));
        color: var(--fg);
        min-height: 100vh;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: 2.5rem 1.5rem 4rem;
      }

      main {
        width: min(1000px, 100%);
        background: var(--panel);
        border-radius: 0.9rem;
        box-shadow: 0 0.85rem 2.4rem rgba(0, 0, 0, 0.5);
        border: 1px solid var(--border);
        padding: 2.25rem;
      }

      h1 {
        margin: 0 0 0.75rem;
        font-size: 1.9rem;
        font-weight: 650;
      }

      p.lead {
        margin: 0 0 1.75rem;
        color: var(--muted);
        line-height: 1.5;
      }

      form {
        display: grid;
        gap: 1.5rem;
      }

      .message-row {
        background: var(--panel-alt);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 1rem;
        display: grid;
        gap: 0.75rem;
      }

      .row-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .row-header label {
        font-weight: 600;
      }

      select {
        background: var(--textarea-bg);
        border: 1px solid var(--textarea-border);
        color: var(--fg);
        border-radius: 0.55rem;
        padding: 0.55rem 0.75rem;
        font: inherit;
      }

      input.text-input {
        background: var(--textarea-bg);
        border: 1px solid var(--textarea-border);
        color: var(--fg);
        border-radius: 0.55rem;
        padding: 0.55rem 0.75rem;
        font: inherit;
        min-width: 240px;
      }

      textarea {
        width: 100%;
        min-height: 6rem;
        resize: vertical;
        padding: 0.85rem;
        border-radius: 0.6rem;
        border: 1px solid var(--textarea-border);
        background: var(--textarea-bg);
        color: var(--fg);
        font: inherit;
        line-height: 1.45;
      }

      input.text-input:focus,
      textarea:focus,
      select:focus {
        outline: 3px solid rgba(90, 169, 255, 0.25);
        border-color: var(--accent);
      }

      .row-actions {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      button,
      .ghost {
        border: none;
        border-radius: 0.6rem;
        padding: 0.75rem 1.4rem;
        font-size: 1rem;
        font-weight: 650;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }

      button.primary {
        background: linear-gradient(135deg, var(--accent), #82c3ff);
        color: #0a101b;
      }

      button.primary:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
        transform: none;
      }

      button.primary:not(:disabled):hover {
        transform: translateY(-1px);
        box-shadow: 0 0.7rem 1.6rem rgba(90, 169, 255, 0.35);
      }

      button:disabled,
      .ghost:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
        transform: none;
      }

      button.small {
        padding: 0.45rem 0.8rem;
        font-size: 0.92rem;
      }

      .ghost {
        background: transparent;
        color: var(--fg);
        border: 1px solid var(--border);
      }

      .ghost:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .controls {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .hint {
        color: var(--muted);
        font-size: 0.95rem;
      }

      .setting {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        font-size: 0.95rem;
      }

      .setting span {
        color: var(--muted);
        font-weight: 600;
      }

      .status {
        min-height: 1.25rem;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .status.error {
        color: var(--error);
        font-weight: 600;
      }

      .status.success {
        color: var(--success);
        font-weight: 600;
      }

      .panel {
        margin-top: 1.75rem;
        background: var(--panel-alt);
        border-radius: 0.75rem;
        padding: 1.4rem;
        border: 1px solid var(--border);
      }

      .panel h2 {
        margin-top: 0;
        margin-bottom: 0.7rem;
        font-size: 1.1rem;
        font-weight: 650;
      }

      .panel .panel-actions {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        justify-content: flex-end;
        margin-bottom: 0.5rem;
      }

      .agent-configs {
        display: grid;
        gap: 1rem;
        margin-top: 0.75rem;
      }

      .agent-card {
        background: #0c1526;
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 1rem;
        display: grid;
        gap: 0.85rem;
      }

      .agent-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .agent-card h3 {
        margin: 0;
        font-size: 1rem;
        font-weight: 600;
      }

      .agent-card-fields {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }

      .workflow-prompt {
        padding: 1rem 1.25rem;
      }

      .prompt-row {
        display: flex;
        align-items: center;
        gap: 1rem;
        justify-content: space-between;
        flex-wrap: wrap;
      }

      .prompt-text {
        display: grid;
        gap: 0.35rem;
      }

      .rendered-body {
        margin-top: 1rem;
        display: grid;
        gap: 1rem;
      }

      .rendered-item {
        background: #0c1526;
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 1rem;
        overflow-x: auto;
      }

      .rendered-item h3 {
        margin: 0 0 0.75rem;
        font-size: 1rem;
        color: var(--muted);
      }

      .json-table {
        width: 100%;
        border-collapse: collapse;
      }

      .json-table td {
        padding: 0.45rem 0.75rem;
        border-top: 1px solid var(--border);
        vertical-align: top;
      }

      .json-table tr:first-child td {
        border-top: 0;
      }

      .json-key {
        width: 30%;
        font-weight: 600;
        color: var(--accent);
        word-break: break-word;
      }

      .json-value {
        font-family: "SFMono-Regular", "Menlo", "Consolas", "Liberation Mono", monospace;
        word-break: break-word;
      }

      .json-array {
        margin: 0.2rem 0 0.2rem 1.2rem;
        padding: 0;
      }

      .json-array li {
        margin: 0.35rem 0;
      }

      .json-primitive {
        font-family: "SFMono-Regular", "Menlo", "Consolas", "Liberation Mono", monospace;
      }

      .json-string {
        color: var(--success);
      }

      .json-number,
      .json-boolean {
        color: var(--accent);
      }

      .json-null,
      .json-empty {
        color: var(--muted);
        font-style: italic;
      }

      @media (max-width: 720px) {
        main {
          padding: 1.75rem 1.25rem;
        }

        textarea {
          min-height: 8rem;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Prompt Runner</h1>
      <p class="lead">
        Build a multi-turn conversation (developer, user, assistant roles) and send it to the
        backend endpoint that calls <code>OpenAI.responses.create</code>. Copy any textarea with
        one click; only the assistant output is shown—raw payloads are hidden for clarity.
      </p>

      <form
        id="promptForm"
        data-endpoint="/api/prompt-run"
        data-background-endpoint="/api/prompt-run-background"
        data-background-poll-endpoint="/api/prompt-run-background"
        data-background-cancel-endpoint="/api/prompt-run-background"
      >
        <div class="controls">
          <button type="button" class="ghost small" id="loadApproachProposer">
            Load Approach Proposer
          </button>
          <button type="button" class="ghost small" id="loadApproachEvaluator">
            Load Approach Evaluator
          </button>
          <button type="button" class="ghost small" id="loadProblemSolver">
            Load Problem Solver
          </button>
          <button type="button" class="ghost small" id="loadExpertEvaluator">
            Load Expert Evaluator
          </button>
          <button type="button" class="ghost small" id="loadResearcher">Load Researcher</button>
          <button type="button" class="ghost small" id="loadOrchestrator">
            Load Orchestrator
          </button>
        </div>

        <div class="controls">
          <button type="button" class="ghost small" id="startWorkflowWith">
            Initiate agentic workflow with approaches
          </button>
          <button type="button" class="ghost small" id="startWorkflowWithout">
            Initiate agentic workflow without approaches
          </button>
          <button type="button" class="ghost small" id="resumeWorkflow">
            Resume agentic workflow
          </button>
          <button type="button" class="ghost small" id="saveWorkflow">Save current state</button>
          <button type="button" class="ghost small" id="stopWorkflow" disabled>
            Stop workflow
          </button>
        </div>

        <div class="controls">
          <label class="setting" for="stateFilename">
            <span>Workflow filename</span>
            <input
              class="text-input"
              type="text"
              id="stateFilename"
              name="stateFilename"
              value="agentic_workflow_state.json"
              placeholder="agentic_workflow_state.json"
              spellcheck="false"
            />
          </label>
          <span class="hint">
            Used for Save/Resume. Saved in scratchpad/saved_snapshots. ".json" is optional.
          </span>
        </div>

        <div class="controls">
          <label class="setting" for="snapshotSelect">
            <span>Saved snapshots</span>
            <select id="snapshotSelect" name="snapshotSelect"></select>
          </label>
          <button type="button" class="ghost small" id="refreshSnapshots">Refresh snapshots</button>
          <button type="button" class="ghost small" id="rollbackSnapshot">Rollback to snapshot</button>
          <button type="button" class="ghost small" id="resumeSnapshot">Resume from snapshot</button>
          <span class="hint">Snapshots stored in scratchpad/saved_snapshots.</span>
        </div>

        <div class="controls">
          <label class="setting" for="autoRunAgentic">
            <span>Auto-advance workflow</span>
            <input type="checkbox" id="autoRunAgentic" name="autoRunAgentic" />
          </label>
          <label class="setting" for="autoLoopLimit">
            <span>Max solver/evaluator loops (auto)</span>
            <input
              class="text-input"
              type="number"
              id="autoLoopLimit"
              name="autoLoopLimit"
              value="3"
              min="1"
              step="1"
              inputmode="numeric"
            />
          </label>
          <span class="hint">
            Auto-advance answers "Yes" at each workflow prompt; max loops applies only in auto mode.
          </span>
        </div>

        <section class="panel" id="agentConfigPanel">
          <h2>Autonomous agent settings</h2>
          <p class="hint">
            Used only when Auto-advance workflow is enabled. Manual workflow runs use the main
            settings above.
          </p>
          <div class="agent-configs" id="agentConfigList"></div>
        </section>

        <div class="controls">
          <button type="button" class="ghost small" id="addMessage">+ Add message</button>
          <button type="button" class="ghost small" id="addAssistant">+ Add assistant reply</button>
          <button type="button" class="ghost small" id="addFromOutput">
            + Assistant from output
          </button>
          <button type="button" class="ghost small" id="forkConversation">Fork conversation</button>
          <button type="button" class="ghost small" id="copyInputs">Copy inputs</button>
          <button type="button" class="ghost small" id="copyInputsSkipFirst">
            Copy inputs except first msg
          </button>
          <button type="button" class="ghost small" id="clearAllFields">Clear all fields</button>
        </div>

        <div class="controls">
          <label class="setting" for="effortSelect">
            <span>Reasoning effort</span>
            <select id="effortSelect" name="effort">
              <option value="none">None</option>
              <option value="low">Low</option>
              <option value="medium">Medium</option>
              <option value="high" selected>High</option>
              <option value="xhigh">xHigh</option>
            </select>
          </label>
          <label class="setting" for="verbositySelect">
            <span>Verbosity</span>
            <select id="verbositySelect" name="verbosity">
              <option value="low">Low</option>
              <option value="medium">Medium</option>
              <option value="high" selected>High</option>
            </select>
          </label>
          <label class="setting" for="modelSelect">
            <span>Model</span>
            <select id="modelSelect" name="model">
              <option value="gpt-5.1" selected>gpt-5.1</option>
              <option value="gpt-5.2">gpt-5.2</option>
              <option value="gpt-5-pro">gpt-5-pro</option>
              <option value="gpt-5.2-pro">gpt-5.2-pro</option>
            </select>
          </label>
          <label class="setting" for="backgroundSelect">
            <span>Background mode</span>
            <select id="backgroundSelect" name="background">
              <option value="false" selected>False</option>
              <option value="true">True</option>
            </select>
          </label>
        </div>

        <div id="messagesContainer" class="message-list"></div>

        <div class="controls">
          <button type="submit" class="primary">Send to OpenAI</button>
          <button type="button" class="ghost small" id="cancelBackgroundTask" disabled>
            Cancel background task
          </button>
          <div class="status" id="status" aria-live="polite"></div>
        </div>
        <div class="hint" id="responseIdDisplay"></div>

        <section class="panel workflow-prompt" id="workflowPrompt" hidden>
          <div class="prompt-row">
            <div class="prompt-text">
              <strong id="workflowPromptTitle">Continue workflow?</strong>
              <span class="hint" id="workflowPromptMessage"></span>
            </div>
            <div class="row-actions">
              <button type="button" class="primary small" id="workflowPromptYes">Yes</button>
              <button type="button" class="ghost small" id="workflowPromptNo">No</button>
            </div>
          </div>
        </section>
      </form>

      <section class="panel">
        <div style="display: flex; align-items: center; gap: 0.75rem; justify-content: space-between">
          <h2 style="margin: 0">Assistant output</h2>
          <div class="panel-actions">
            <button type="button" class="ghost small" id="copyOutput">Copy</button>
          </div>
        </div>
        <textarea
          id="outputBox"
          readonly
          placeholder="The model output will appear here in full."
          style="min-height: 12rem"
        ></textarea>
      </section>

      <section class="panel">
        <div style="display: flex; align-items: center; gap: 0.75rem; justify-content: space-between">
          <h2 style="margin: 0">Last sent payload</h2>
          <div class="panel-actions">
            <button type="button" class="ghost small" id="copyPayload">Copy</button>
          </div>
        </div>
        <textarea
          id="payloadBox"
          readonly
          placeholder="The full payload sent to OpenAI will appear here."
          style="min-height: 10rem"
        ></textarea>
      </section>

      <section class="panel">
        <div style="display: flex; align-items: center; gap: 0.75rem; justify-content: space-between">
          <h2 style="margin: 0">Full response output</h2>
          <div class="panel-actions">
            <button type="button" class="ghost small" id="copyFullResponse">Copy</button>
          </div>
        </div>
        <textarea
          id="fullResponseBox"
          readonly
          placeholder="The full model response payload will appear here."
          style="min-height: 12rem"
        ></textarea>
      </section>

      <section class="panel" id="orchestratorPanel">
        <div style="display: flex; align-items: center; gap: 0.75rem; justify-content: space-between">
          <h2 style="margin: 0">Orchestrator decision (parsed JSON)</h2>
          <div class="panel-actions">
            <button type="button" class="ghost small" id="copyOrchestratorJson">Copy JSON</button>
          </div>
        </div>
        <textarea
          id="orchestratorJson"
          readonly
          placeholder="Parsed orchestrator JSON will appear here."
          style="min-height: 10rem"
        ></textarea>
        <div id="orchestratorRendered" class="rendered-body">
          <p class="hint">Rendered orchestrator output will appear here.</p>
        </div>
      </section>
    </main>

    <script>
      const form = document.getElementById("promptForm");
      const messagesContainer = document.getElementById("messagesContainer");
      const statusEl = document.getElementById("status");
      const outputBox = document.getElementById("outputBox");
      const addMessageBtn = document.getElementById("addMessage");
      const addAssistantBtn = document.getElementById("addAssistant");
      const addAssistantFromOutputBtn = document.getElementById("addFromOutput");
      const copyInputsBtn = document.getElementById("copyInputs");
      const copyInputsSkipFirstBtn = document.getElementById("copyInputsSkipFirst");
      const clearAllFieldsBtn = document.getElementById("clearAllFields");
      const copyOutputBtn = document.getElementById("copyOutput");
      const payloadBox = document.getElementById("payloadBox");
      const copyPayloadBtn = document.getElementById("copyPayload");
      const effortSelect = document.getElementById("effortSelect");
      const verbositySelect = document.getElementById("verbositySelect");
      const modelSelect = document.getElementById("modelSelect");
      const backgroundSelect = document.getElementById("backgroundSelect");
      const agentConfigList = document.getElementById("agentConfigList");
      const fullResponseBox = document.getElementById("fullResponseBox");
      const copyFullResponseBtn = document.getElementById("copyFullResponse");
      const responseIdDisplay = document.getElementById("responseIdDisplay");
      const cancelBackgroundBtn = document.getElementById("cancelBackgroundTask");
      const forkConversationBtn = document.getElementById("forkConversation");
      const loadApproachProposerBtn = document.getElementById("loadApproachProposer");
      const loadApproachEvaluatorBtn = document.getElementById("loadApproachEvaluator");
      const loadProblemSolverBtn = document.getElementById("loadProblemSolver");
      const loadExpertEvaluatorBtn = document.getElementById("loadExpertEvaluator");
      const loadResearcherBtn = document.getElementById("loadResearcher");
      const loadOrchestratorBtn = document.getElementById("loadOrchestrator");
      const startWorkflowWithBtn = document.getElementById("startWorkflowWith");
      const startWorkflowWithoutBtn = document.getElementById("startWorkflowWithout");
      const resumeWorkflowBtn = document.getElementById("resumeWorkflow");
      const saveWorkflowBtn = document.getElementById("saveWorkflow");
      const stopWorkflowBtn = document.getElementById("stopWorkflow");
      const stateFilenameInput = document.getElementById("stateFilename");
      const snapshotSelect = document.getElementById("snapshotSelect");
      const refreshSnapshotsBtn = document.getElementById("refreshSnapshots");
      const rollbackSnapshotBtn = document.getElementById("rollbackSnapshot");
      const resumeSnapshotBtn = document.getElementById("resumeSnapshot");
      const autoRunAgenticCheckbox = document.getElementById("autoRunAgentic");
      const autoLoopLimitInput = document.getElementById("autoLoopLimit");
      const workflowPrompt = document.getElementById("workflowPrompt");
      const workflowPromptTitle = document.getElementById("workflowPromptTitle");
      const workflowPromptMessage = document.getElementById("workflowPromptMessage");
      const workflowPromptYes = document.getElementById("workflowPromptYes");
      const workflowPromptNo = document.getElementById("workflowPromptNo");
      const orchestratorJson = document.getElementById("orchestratorJson");
      const orchestratorRendered = document.getElementById("orchestratorRendered");
      const copyOrchestratorJsonBtn = document.getElementById("copyOrchestratorJson");
      const POLL_INTERVAL_MS = 60000;
      const DEFAULT_CANCEL_BUTTON_TEXT = "Cancel background task";
      const DEFAULT_STATE_FILENAME = "agentic_workflow_state.json";
      const DEFAULT_AUTO_LOOP_LIMIT = 3;
      const AUTO_ADVANCE_DELAY_MS = 150;
      const AUTO_RETRY_LIMIT = 1;
      const SNAPSHOT_LABEL_MAX = 160;
      const agentConfigControls = new Map();
      let currentBackgroundRun = null;
      let autoAdvanceTimer = null;
      let currentStageController = null;

      const ROLE_PLACEHOLDERS = {
        developer:
          "System or developer guidance. Example: Keep outputs in markdown unless instructed otherwise.",
        user: "User request or follow-up. Example: Explain prime numbers.",
        assistant: "Assistant reply to seed the conversation. Example: A concise answer to the user.",
      };
      const KEYWORD_REGEX = /\b(problem|question|research)\b/i;
      const AGENTIC_STAGES = {
        approach_proposer: { key: "approach-proposer", label: "Approach Proposer" },
        approach_evaluator: { key: "approach-evaluator", label: "Approach Evaluator" },
        problem_solver: { key: "problem-solver", label: "Problem Solver" },
        expert_evaluator: { key: "expert-evaluator", label: "Expert Evaluator" },
        orchestrator: { key: "orchestrator", label: "Orchestrator" },
      };
      const AGENT_CONFIG_ORDER = [
        "approach_proposer",
        "approach_evaluator",
        "problem_solver",
        "expert_evaluator",
        "orchestrator",
      ];
      const MODEL_OPTIONS = [
        { value: "gpt-5.1", label: "gpt-5.1" },
        { value: "gpt-5.2", label: "gpt-5.2" },
        { value: "gpt-5-pro", label: "gpt-5-pro" },
        { value: "gpt-5.2-pro", label: "gpt-5.2-pro" },
      ];
      const VERBOSITY_OPTIONS = [
        { value: "low", label: "Low" },
        { value: "medium", label: "Medium" },
        { value: "high", label: "High" },
      ];
      const REASONING_OPTIONS = [
        { value: "none", label: "None" },
        { value: "low", label: "Low" },
        { value: "medium", label: "Medium" },
        { value: "high", label: "High" },
        { value: "xhigh", label: "xHigh" },
      ];
      const BACKGROUND_OPTIONS = [
        { value: "false", label: "False" },
        { value: "true", label: "True" },
      ];
      const AGENT_SETTING_DEFAULTS = {
        model: "gpt-5.1",
        reasoning_effort: "high",
        text_verbosity: "high",
        background: false,
      };
      const INITIAL_QUEUES = {
        with_approaches: [
          "approach_proposer",
          "approach_evaluator",
          "problem_solver",
          "expert_evaluator",
          "orchestrator",
        ],
        without_approaches: ["problem_solver", "expert_evaluator", "orchestrator"],
      };
      const LOOP_QUEUE = ["problem_solver", "expert_evaluator", "orchestrator"];
      const agenticState = {
        active: false,
        workflowType: null,
        queue: [],
        loopCount: 0,
        error: null,
        completed: false,
        lastStage: null,
        lastOrchestrator: null,
        running: false,
        stopRequested: false,
      };
      let workflowPromptConfig = null;

      const normalizeRole = (value) => {
        const lower = typeof value === "string" ? value.trim().toLowerCase() : "";
        return ["developer", "user", "assistant"].includes(lower) ? lower : "user";
      };

      const createOption = (value, label, selected) => {
        const opt = document.createElement("option");
        opt.value = value;
        opt.textContent = label;
        if (selected) opt.selected = true;
        return opt;
      };

      const buildSelect = (options, selectedValue) => {
        const select = document.createElement("select");
        options.forEach((option) => {
          const value = typeof option === "string" ? option : option.value;
          const label = typeof option === "string" ? option : option.label;
          select.appendChild(createOption(value, label, value === selectedValue));
        });
        return select;
      };

      const buildSettingField = (labelText, selectEl) => {
        const label = document.createElement("label");
        label.className = "setting";
        const span = document.createElement("span");
        span.textContent = labelText;
        label.append(span, selectEl);
        return label;
      };

      const normalizeChoice = (value, options, fallback) => {
        const candidate = typeof value === "string" ? value : "";
        const match = options.some((option) => {
          const optionValue = typeof option === "string" ? option : option.value;
          return optionValue === candidate;
        });
        return match ? candidate : fallback;
      };

      const normalizeAgentSettings = (settings, fallback) => {
        const base = fallback || AGENT_SETTING_DEFAULTS;
        return {
          model: normalizeChoice(settings?.model, MODEL_OPTIONS, base.model),
          text_verbosity: normalizeChoice(
            settings?.text_verbosity,
            VERBOSITY_OPTIONS,
            base.text_verbosity
          ),
          reasoning_effort: normalizeChoice(
            settings?.reasoning_effort,
            REASONING_OPTIONS,
            base.reasoning_effort
          ),
          background:
            typeof settings?.background === "boolean" ? settings.background : base.background,
        };
      };

      const buildAgentConfigCard = (agentKey, defaults) => {
        if (!agentConfigList) return null;
        const stageInfo = AGENTIC_STAGES[agentKey];
        const safeDefaults = normalizeAgentSettings(defaults, AGENT_SETTING_DEFAULTS);

        const card = document.createElement("div");
        card.className = "agent-card";
        card.dataset.agent = agentKey;

        const header = document.createElement("div");
        header.className = "agent-card-header";
        const title = document.createElement("h3");
        title.textContent = stageInfo?.label || agentKey;
        header.appendChild(title);
        card.appendChild(header);

        const fields = document.createElement("div");
        fields.className = "agent-card-fields";

        const modelSelect = buildSelect(MODEL_OPTIONS, safeDefaults.model);
        const verbositySelect = buildSelect(VERBOSITY_OPTIONS, safeDefaults.text_verbosity);
        const effortSelect = buildSelect(REASONING_OPTIONS, safeDefaults.reasoning_effort);
        const backgroundSelect = buildSelect(
          BACKGROUND_OPTIONS,
          safeDefaults.background ? "true" : "false"
        );

        fields.append(
          buildSettingField("Model", modelSelect),
          buildSettingField("Verbosity", verbositySelect),
          buildSettingField("Reasoning effort", effortSelect),
          buildSettingField("Background mode", backgroundSelect)
        );

        card.appendChild(fields);
        agentConfigControls.set(agentKey, {
          model: modelSelect,
          verbosity: verbositySelect,
          effort: effortSelect,
          background: backgroundSelect,
        });
        return card;
      };

      const collectConversationMessages = () =>
        Array.from(messagesContainer.querySelectorAll(".message-row")).map((row) => {
          const select = row.querySelector("select");
          const textarea = row.querySelector("textarea");
          const role = normalizeRole(select?.value || "user");
          const text = typeof textarea?.value === "string" ? textarea.value : "";
          return { role, text };
        });

      const showStatus = (message, type = "") => {
        statusEl.textContent = message || "";
        statusEl.classList.remove("error", "success");
        if (type) statusEl.classList.add(type);
      };

      const setResponseId = (idText) => {
        if (!responseIdDisplay) return;
        responseIdDisplay.textContent = idText ? `response_id: ${idText}` : "";
      };

      const normalizeStatus = (statusText) =>
        (typeof statusText === "string" ? statusText : "")
          .toLowerCase()
          .replace(/_/g, " ")
          .trim();

      const isAbortError = (error) => error && error.name === "AbortError";

      const updateCancelButton = (statusText = "") => {
        if (!cancelBackgroundBtn) return;
        const normalized = normalizeStatus(statusText || currentBackgroundRun?.lastStatus || "");
        const hasActiveRun = Boolean(currentBackgroundRun?.responseId);
        const isInProgress = normalized === "in progress";
        const isBusy = Boolean(currentBackgroundRun?.cancelInFlight);
        cancelBackgroundBtn.disabled = !(hasActiveRun && isInProgress) || isBusy;
        cancelBackgroundBtn.textContent = isBusy ? "Cancelling…" : DEFAULT_CANCEL_BUTTON_TEXT;
      };

      const resetCancelButton = () => {
        if (!cancelBackgroundBtn) return;
        cancelBackgroundBtn.disabled = true;
        cancelBackgroundBtn.textContent = DEFAULT_CANCEL_BUTTON_TEXT;
      };

      const updateStopButtonState = () => {
        if (!stopWorkflowBtn) return;
        const isRunning = Boolean(agenticState.running || autoAdvanceTimer);
        stopWorkflowBtn.disabled = !isRunning;
      };

      const clearBackgroundRunState = () => {
        currentBackgroundRun = null;
        resetCancelButton();
        updateStopButtonState();
      };

      const markBackgroundStatus = (statusText) => {
        if (!currentBackgroundRun) return;
        const normalized = normalizeStatus(statusText);
        currentBackgroundRun.lastStatus = normalized || statusText;
        updateCancelButton(currentBackgroundRun.lastStatus);
      };

      const copyText = async (text, button) => {
        try {
          await navigator.clipboard.writeText(text);
          if (button) {
            const previous = button.textContent;
            button.textContent = "Copied!";
            button.disabled = true;
            setTimeout(() => {
              button.textContent = previous;
              button.disabled = false;
            }, 800);
          }
          return true;
        } catch (error) {
          console.error("Clipboard error", error);
          showStatus("Copy failed. Check clipboard permissions.", "error");
          return false;
        }
      };

      const parseResponseBody = async (response) => {
        const rawText = await response.text();
        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch {
          parsed = rawText;
        }
        const ok = response.ok && parsed && parsed.ok !== false;
        return { rawText, parsed, ok, status: response.status };
      };

      const extractOutputText = (payload) => {
        if (!payload) return "";

        if (typeof payload.output_text === "string" && payload.output_text.trim()) {
          return payload.output_text.trim();
        }

        const response = payload.response || payload;
        const outputItems = response && response.output;
        if (!Array.isArray(outputItems)) return "";

        const chunks = [];
        for (const item of outputItems) {
          if (!item || item.type !== "message" || !Array.isArray(item.content)) continue;
          for (const block of item.content) {
            if (block && block.type === "output_text" && typeof block.text === "string") {
              const t = block.text.trim();
              if (t) chunks.push(t);
            }
          }
        }

        return chunks.join("\n\n").trim();
      };

      const cancelBackgroundTask = async (options = {}) => {
        const { silent = false, force = false } = options;
        if (!currentBackgroundRun?.responseId) {
          if (!silent) showStatus("No background task is currently running.", "error");
          return false;
        }

        const statusForCancel = currentBackgroundRun.lastStatus || "";
        const normalizedStatus = normalizeStatus(statusForCancel);
        if (!force && normalizedStatus !== "in progress") {
          if (!silent) {
            showStatus("Cancellation is available only while a task is in progress.", "error");
          }
          return false;
        }

        currentBackgroundRun.cancelInFlight = true;
        updateCancelButton(statusForCancel);
        if (!silent) showStatus("Cancelling background task…");

        const baseCancelEndpoint =
          currentBackgroundRun?.cancelEndpointBase ||
          form.dataset.backgroundCancelEndpoint ||
          form.dataset.backgroundPollEndpoint ||
          form.dataset.backgroundEndpoint ||
          "/api/prompt-run-background";
        const cancelUrl = `${baseCancelEndpoint.replace(/\/$/, "")}/${encodeURIComponent(
          currentBackgroundRun.responseId
        )}/cancel`;

        try {
          const cancelResp = await fetch(cancelUrl, { method: "POST" });
          const { parsed, ok, status } = await parseResponseBody(cancelResp);
          if (!ok) {
            const err =
              (parsed && parsed.error) ||
              (typeof parsed === "string" ? parsed : null) ||
              `Cancel failed with status ${status}`;
            throw new Error(err);
          }

          const responsePayload = (parsed && (parsed.response || parsed)) || parsed;
          const finalStatusRaw =
            (parsed && parsed.status) ||
            (parsed && parsed.response && parsed.response.status) ||
            "cancelled";
          const finalStatus = normalizeStatus(finalStatusRaw) || finalStatusRaw || "cancelled";
          const extractedText = extractOutputText(responsePayload);
          const pretty =
            typeof responsePayload === "object"
              ? JSON.stringify(responsePayload, null, 2)
              : String(responsePayload);

          if (extractedText) outputBox.value = extractedText;
          if (fullResponseBox) fullResponseBox.value = pretty || "";

          const statusType =
            finalStatus === "cancelled" ? "success" : finalStatus === "failed" ? "error" : "";
          if (!silent) {
            showStatus(`Background task cancelled (${finalStatus}).`, statusType);
          }
          setResponseId(
            (parsed && parsed.response_id) ||
            (parsed && parsed.response && parsed.response.id) ||
            currentBackgroundRun.responseId
          );
          currentBackgroundRun.cancelledPayload = responsePayload;
          currentBackgroundRun.lastStatus = finalStatus;
          if (currentBackgroundRun.controller) currentBackgroundRun.controller.abort();
          return true;
        } catch (error) {
          console.error("Cancellation error", error);
          if (!silent) {
            showStatus(
              `Cancel failed: ${error && error.message ? error.message : "Unknown error"}`,
              "error"
            );
          }
          currentBackgroundRun.cancelInFlight = false;
          updateCancelButton(currentBackgroundRun.lastStatus);
          return false;
        }
      };

      const renderOrchestratorPlaceholder = (message) => {
        if (!orchestratorRendered) return;
        orchestratorRendered.replaceChildren();
        const helper = document.createElement("p");
        helper.className = "hint";
        helper.textContent = message;
        orchestratorRendered.appendChild(helper);
      };

      const buildPrimitiveNode = (value) => {
        const span = document.createElement("span");
        span.className = "json-primitive";
        if (value === null) {
          span.classList.add("json-null");
          span.textContent = "null";
          return span;
        }
        switch (typeof value) {
          case "string":
            span.classList.add("json-string");
            span.textContent = value;
            break;
          case "number":
            span.classList.add("json-number");
            span.textContent = String(value);
            break;
          case "boolean":
            span.classList.add("json-boolean");
            span.textContent = value ? "true" : "false";
            break;
          default:
            span.textContent = String(value);
        }
        return span;
      };

      const buildArrayNode = (value) => {
        if (!value.length) {
          const empty = document.createElement("span");
          empty.className = "json-empty";
          empty.textContent = "[]";
          return empty;
        }
        const list = document.createElement("ol");
        list.className = "json-array";
        value.forEach((item) => {
          const li = document.createElement("li");
          li.appendChild(buildValueNode(item));
          list.appendChild(li);
        });
        return list;
      };

      const buildObjectNode = (value) => {
        const entries = Object.entries(value);
        if (!entries.length) {
          const empty = document.createElement("span");
          empty.className = "json-empty";
          empty.textContent = "{}";
          return empty;
        }
        const table = document.createElement("table");
        table.className = "json-table";
        const body = document.createElement("tbody");
        entries.forEach(([key, val]) => {
          const row = document.createElement("tr");
          const keyCell = document.createElement("td");
          keyCell.className = "json-key";
          keyCell.textContent = key;
          const valueCell = document.createElement("td");
          valueCell.className = "json-value";
          valueCell.appendChild(buildValueNode(val));
          row.appendChild(keyCell);
          row.appendChild(valueCell);
          body.appendChild(row);
        });
        table.appendChild(body);
        return table;
      };

      const buildValueNode = (value) => {
        if (Array.isArray(value)) {
          return buildArrayNode(value);
        }
        if (value && typeof value === "object") {
          return buildObjectNode(value);
        }
        return buildPrimitiveNode(value);
      };

      const renderOrchestratorOutput = (output) => {
        if (!orchestratorRendered) return;
        orchestratorRendered.replaceChildren();
        if (!output) {
          renderOrchestratorPlaceholder("No parsed orchestrator output available.");
          return;
        }
        const item = document.createElement("div");
        item.className = "rendered-item";
        const heading = document.createElement("h3");
        heading.textContent = "Parsed output";
        item.appendChild(heading);
        item.appendChild(buildValueNode(output));
        orchestratorRendered.appendChild(item);
      };

      const setOrchestratorOutput = (parsed, rawText) => {
        if (orchestratorJson) {
          orchestratorJson.value = rawText || (parsed ? JSON.stringify(parsed, null, 2) : "");
        }
        renderOrchestratorOutput(parsed);
        agenticState.lastOrchestrator = parsed
          ? { parsed, rawText: rawText || JSON.stringify(parsed, null, 2) }
          : null;
      };

      const getSettingsSnapshot = () => ({
        model: modelSelect?.value || "gpt-5.1",
        reasoning_effort: effortSelect?.value || "high",
        text_verbosity: verbositySelect?.value || "high",
        background: (backgroundSelect?.value || "false") === "true",
      });

      const initializeAgentConfigs = () => {
        if (!agentConfigList) return;
        agentConfigControls.clear();
        agentConfigList.replaceChildren();
        const defaults = getSettingsSnapshot();
        AGENT_CONFIG_ORDER.forEach((agentKey) => {
          const card = buildAgentConfigCard(agentKey, defaults);
          if (card) agentConfigList.appendChild(card);
        });
      };

      const getAgentSettingsSnapshot = () => {
        const snapshot = {};
        AGENT_CONFIG_ORDER.forEach((agentKey) => {
          const controls = agentConfigControls.get(agentKey);
          if (!controls) return;
          snapshot[agentKey] = normalizeAgentSettings(
            {
              model: controls.model?.value,
              text_verbosity: controls.verbosity?.value,
              reasoning_effort: controls.effort?.value,
              background: (controls.background?.value || "false") === "true",
            },
            AGENT_SETTING_DEFAULTS
          );
        });
        return snapshot;
      };

      const applyAgentSettingsSnapshot = (settingsMap) => {
        const fallback = getSettingsSnapshot();
        AGENT_CONFIG_ORDER.forEach((agentKey) => {
          const controls = agentConfigControls.get(agentKey);
          if (!controls) return;
          const normalized = normalizeAgentSettings(settingsMap?.[agentKey], fallback);
          controls.model.value = normalized.model;
          controls.verbosity.value = normalized.text_verbosity;
          controls.effort.value = normalized.reasoning_effort;
          controls.background.value = normalized.background ? "true" : "false";
        });
      };

      const getAgentSettingsForStage = (stage) => {
        const controls = agentConfigControls.get(stage);
        if (!controls) return null;
        return normalizeAgentSettings(
          {
            model: controls.model?.value,
            text_verbosity: controls.verbosity?.value,
            reasoning_effort: controls.effort?.value,
            background: (controls.background?.value || "false") === "true",
          },
          getSettingsSnapshot()
        );
      };

      const resolveStageSettings = (stage) => {
        if (!getAutoRunEnabled()) return getSettingsSnapshot();
        return getAgentSettingsForStage(stage) || getSettingsSnapshot();
      };

      const getStateFilename = () => {
        if (!stateFilenameInput) return DEFAULT_STATE_FILENAME;
        const value =
          typeof stateFilenameInput.value === "string" ? stateFilenameInput.value.trim() : "";
        return value || DEFAULT_STATE_FILENAME;
      };

      const parsePositiveInt = (value) => {
        const parsed = Number.parseInt(value, 10);
        return Number.isInteger(parsed) && parsed > 0 ? parsed : null;
      };

      const getAutoRunEnabled = () => Boolean(autoRunAgenticCheckbox?.checked);

      const getAutoLoopLimit = () => {
        const parsed = parsePositiveInt(autoLoopLimitInput?.value);
        return parsed ?? DEFAULT_AUTO_LOOP_LIMIT;
      };

      const normalizeAutoLoopLimitInput = () => {
        if (!autoLoopLimitInput) return;
        const parsed = parsePositiveInt(autoLoopLimitInput.value);
        if (!parsed) {
          autoLoopLimitInput.value = String(DEFAULT_AUTO_LOOP_LIMIT);
        }
      };

      const syncAutoRunControls = () => {
        if (!autoLoopLimitInput) return;
        autoLoopLimitInput.disabled = !getAutoRunEnabled();
      };

      const buildAgenticStateUrl = (filename) => {
        const clean = typeof filename === "string" ? filename.trim() : "";
        if (!clean) return "/api/agentic-state";
        return `/api/agentic-state?filename=${encodeURIComponent(clean)}`;
      };

      const buildStateSnapshot = (note = "") => ({
        version: 1,
        saved_at: new Date().toISOString(),
        note,
        state_filename: getStateFilename(),
        messages: collectConversationMessages(),
        settings: getSettingsSnapshot(),
        agent_settings: getAgentSettingsSnapshot(),
        workflow: {
          active: agenticState.active,
          workflowType: agenticState.workflowType,
          queue: Array.isArray(agenticState.queue) ? [...agenticState.queue] : [],
          loopCount: agenticState.loopCount,
          error: agenticState.error,
          completed: agenticState.completed,
          lastStage: agenticState.lastStage,
          autoRun: getAutoRunEnabled(),
          autoLoopLimit: getAutoLoopLimit(),
        },
        last_orchestrator: agenticState.lastOrchestrator,
      });

      const slugifyLabel = (value) => {
        if (!value) return "";
        return String(value)
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-+|-+$/g, "")
          .replace(/-{2,}/g, "-");
      };

      const buildSnapshotLabel = (state) => {
        const savedAt =
          state && typeof state.saved_at === "string" ? state.saved_at : new Date().toISOString();
        const timestamp = savedAt.replace(/[:.]/g, "-");
        const parts = [timestamp];
        const noteSlug = slugifyLabel(state?.note);
        if (noteSlug) parts.push(noteSlug);
        const loopCount = state?.workflow?.loopCount;
        if (Number.isInteger(loopCount)) parts.push(`loop-${loopCount}`);
        const stageSlug = slugifyLabel(state?.workflow?.lastStage);
        if (stageSlug) parts.push(`stage-${stageSlug}`);
        let label = parts.filter(Boolean).join("_") || "snapshot";
        if (label.length > SNAPSHOT_LABEL_MAX) {
          label = label.slice(0, SNAPSHOT_LABEL_MAX);
        }
        return label;
      };

      const buildSnapshotOptionLabel = (snapshot) => {
        if (!snapshot || typeof snapshot !== "object") return "Snapshot";
        const parts = [];
        if (snapshot.saved_at) parts.push(snapshot.saved_at);
        if (snapshot.note) parts.push(snapshot.note);
        if (Number.isInteger(snapshot.loop_count)) parts.push(`loop ${snapshot.loop_count}`);
        if (snapshot.last_stage) parts.push(`stage ${snapshot.last_stage}`);
        if (!parts.length && snapshot.filename) return snapshot.filename;
        return parts.join(" - ");
      };

      const renderSnapshotOptions = (snapshots, selected = "") => {
        if (!snapshotSelect) return;
        snapshotSelect.innerHTML = "";
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = snapshots.length ? "Select a snapshot" : "No snapshots found";
        snapshotSelect.appendChild(placeholder);

        snapshots.forEach((snapshot) => {
          if (!snapshot || !snapshot.filename) return;
          const option = document.createElement("option");
          option.value = snapshot.filename;
          option.textContent = buildSnapshotOptionLabel(snapshot);
          if (snapshot.filename === selected) option.selected = true;
          snapshotSelect.appendChild(option);
        });
      };

      const refreshSnapshotList = async (options = {}) => {
        const { silent = false } = options;
        if (!snapshotSelect) return [];
        const filename = getStateFilename();
        const endpoint = `/api/agentic-snapshots?filename=${encodeURIComponent(filename)}`;
        try {
          const response = await fetch(endpoint);
          const { parsed, ok, status } = await parseResponseBody(response);
          if (!ok) {
            const err =
              (parsed && parsed.error) ||
              (typeof parsed === "string" ? parsed : null) ||
              `Snapshot load failed with status ${status}`;
            if (!silent) showStatus(err, "error");
            renderSnapshotOptions([]);
            return [];
          }
          const snapshots = Array.isArray(parsed?.snapshots) ? parsed.snapshots : [];
          const selected = snapshotSelect?.value || "";
          renderSnapshotOptions(snapshots, selected);
          if (!silent) {
            showStatus(
              snapshots.length
                ? `Loaded ${snapshots.length} snapshots.`
                : "No snapshots found.",
              "success"
            );
          }
          return snapshots;
        } catch (error) {
          console.error("Snapshot list error", error);
          if (!silent) {
            showStatus(
              `Snapshot list failed: ${error && error.message ? error.message : "Unknown error"}`,
              "error"
            );
          }
          renderSnapshotOptions([]);
          return [];
        }
      };

      const saveSnapshot = async (state, options = {}) => {
        const { silent = false } = options;
        if (!state || typeof state !== "object") return false;
        const label = buildSnapshotLabel(state);
        const filename = getStateFilename();
        try {
          const response = await fetch("/api/agentic-snapshot", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ state, filename, label }),
          });
          const { parsed, ok, status } = await parseResponseBody(response);
          if (!ok) {
            const err =
              (parsed && parsed.error) ||
              (typeof parsed === "string" ? parsed : null) ||
              `Snapshot save failed with status ${status}`;
            if (!silent) showStatus(err, "error");
            return false;
          }
          await refreshSnapshotList({ silent: true });
          return true;
        } catch (error) {
          console.error("Snapshot save error", error);
          if (!silent) {
            showStatus(
              `Snapshot save failed: ${error && error.message ? error.message : "Unknown error"}`,
              "error"
            );
          }
          return false;
        }
      };

      const loadSnapshotState = async (snapshotFilename) => {
        if (!snapshotFilename) {
          throw new Error("Snapshot filename is required.");
        }
        const endpoint = `/api/agentic-snapshot?name=${encodeURIComponent(snapshotFilename)}`;
        const response = await fetch(endpoint);
        const { parsed, ok, status } = await parseResponseBody(response);
        if (!ok) {
          const err =
            (parsed && parsed.error) ||
            (typeof parsed === "string" ? parsed : null) ||
            `Snapshot load failed with status ${status}`;
          throw new Error(err);
        }
        if (!parsed || typeof parsed.state !== "object") {
          throw new Error("Snapshot payload is invalid.");
        }
        return parsed.state;
      };

      const saveAgenticState = async (note, options = {}) => {
        const { silent = false, createSnapshot = false } = options;
        const snapshot = buildStateSnapshot(note);
        const filename = getStateFilename();
        const endpoint = buildAgenticStateUrl(filename);
        try {
          const response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ state: snapshot, filename }),
          });
          const { parsed, ok, status } = await parseResponseBody(response);
          if (!ok) {
            const err =
              (parsed && parsed.error) ||
              (typeof parsed === "string" ? parsed : null) ||
              `Save failed with status ${status}`;
            if (!silent) showStatus(err, "error");
            return false;
          }
          let snapshotSaved = true;
          if (createSnapshot) {
            snapshotSaved = await saveSnapshot(snapshot, { silent: true });
          }
          if (!silent) {
            if (createSnapshot) {
              showStatus(
                snapshotSaved
                  ? `Workflow state and snapshot saved (${filename}).`
                  : `Workflow state saved (${filename}), but snapshot failed.`,
                snapshotSaved ? "success" : "error"
              );
            } else {
              showStatus(`Workflow state saved (${filename}).`, "success");
            }
          }
          return true;
        } catch (error) {
          console.error("Save state error", error);
          if (!silent) {
            showStatus(
              `Save failed: ${error && error.message ? error.message : "Unknown error"}`,
              "error"
            );
          }
          return false;
        }
      };

      const loadAgenticState = async () => {
        const filename = getStateFilename();
        const endpoint = buildAgenticStateUrl(filename);
        const response = await fetch(endpoint);
        const { parsed, ok, status } = await parseResponseBody(response);
        if (!ok) {
          const err =
            (parsed && parsed.error) ||
            (typeof parsed === "string" ? parsed : null) ||
            `Load failed with status ${status}`;
          throw new Error(err);
        }
        if (!parsed || typeof parsed.state !== "object") {
          throw new Error("Saved state response is invalid.");
        }
        return parsed.state;
      };

      const applyStateSnapshot = (state) => {
        if (!state || typeof state !== "object") return;
        const messages = Array.isArray(state.messages) ? state.messages : [];
        messagesContainer.innerHTML = "";
        messages.forEach((entry) => {
          const role = normalizeRole(entry?.role || "user");
          const text = typeof entry?.text === "string" ? entry.text : "";
          addMessageRow(role, text);
        });
        if (!messages.length) {
          addMessageRow("developer");
          addMessageRow("user");
        }

        if (stateFilenameInput) {
          const savedFilename =
            typeof state.state_filename === "string" ? state.state_filename.trim() : "";
          if (savedFilename) {
            stateFilenameInput.value = savedFilename;
          } else if (!stateFilenameInput.value.trim()) {
            stateFilenameInput.value = DEFAULT_STATE_FILENAME;
          }
        }

        if (state.settings) {
          const settings = state.settings;
          if (settings.model && modelSelect) modelSelect.value = settings.model;
          if (settings.text_verbosity && verbositySelect)
            verbositySelect.value = settings.text_verbosity;
          if (settings.reasoning_effort && effortSelect)
            effortSelect.value = settings.reasoning_effort;
          if (typeof settings.background === "boolean" && backgroundSelect) {
            backgroundSelect.value = settings.background ? "true" : "false";
          }
        }
        applyAgentSettingsSnapshot(state.agent_settings);

        if (autoRunAgenticCheckbox) {
          autoRunAgenticCheckbox.checked = Boolean(state.workflow?.autoRun);
        }
        if (autoLoopLimitInput) {
          const savedLimit = parsePositiveInt(state.workflow?.autoLoopLimit);
          autoLoopLimitInput.value = String(savedLimit ?? DEFAULT_AUTO_LOOP_LIMIT);
        }
        syncAutoRunControls();

        const workflow = state.workflow || {};
        agenticState.active = Boolean(workflow.active);
        agenticState.workflowType = workflow.workflowType || null;
        agenticState.queue = Array.isArray(workflow.queue) ? [...workflow.queue] : [];
        agenticState.loopCount = Number.isInteger(workflow.loopCount) ? workflow.loopCount : 0;
        agenticState.error = workflow.error || null;
        agenticState.completed = Boolean(workflow.completed);
        agenticState.lastStage = workflow.lastStage || null;
        agenticState.running = false;
        agenticState.stopRequested = false;
        agenticState.lastOrchestrator = state.last_orchestrator || null;
        updateStopButtonState();

        if (agenticState.lastOrchestrator?.parsed) {
          setOrchestratorOutput(
            agenticState.lastOrchestrator.parsed,
            agenticState.lastOrchestrator.rawText
          );
        } else {
          if (orchestratorJson) orchestratorJson.value = "";
          renderOrchestratorPlaceholder("Rendered orchestrator output will appear here.");
        }
      };

      const showWorkflowPrompt = ({
        title,
        message,
        yesLabel = "Yes",
        noLabel = "No",
        onYes,
        onNo,
      }) => {
        if (!workflowPrompt) return;
        workflowPromptTitle.textContent = title || "Continue workflow?";
        workflowPromptMessage.textContent = message || "";
        workflowPromptYes.textContent = yesLabel;
        workflowPromptNo.textContent = noLabel;
        workflowPromptConfig = { onYes, onNo };
        workflowPrompt.hidden = false;
      };

      const hideWorkflowPrompt = () => {
        if (!workflowPrompt) return;
        workflowPrompt.hidden = true;
        workflowPromptConfig = null;
      };

      const clearAutoAdvanceTimer = () => {
        if (autoAdvanceTimer) {
          clearTimeout(autoAdvanceTimer);
          autoAdvanceTimer = null;
        }
        updateStopButtonState();
      };

      const scheduleAutoAdvance = (message, onYes) => {
        hideWorkflowPrompt();
        if (message) showStatus(message);
        if (typeof onYes !== "function") return;
        clearAutoAdvanceTimer();
        autoAdvanceTimer = setTimeout(() => {
          autoAdvanceTimer = null;
          updateStopButtonState();
          if (agenticState.stopRequested) return;
          onYes();
        }, AUTO_ADVANCE_DELAY_MS);
        updateStopButtonState();
      };

      const sleep = (ms, signal) =>
        new Promise((resolve, reject) => {
          const timer = setTimeout(resolve, ms);
          if (!signal) return;
          signal.addEventListener(
            "abort",
            () => {
              clearTimeout(timer);
              reject(new DOMException("Aborted", "AbortError"));
            },
            { once: true }
          );
        });

      const pollForCompletion = async (responseId, pollBaseUrl, options = {}) => {
        const { signal, onStatus } = options;
        const base = (pollBaseUrl || "/api/prompt-run-background").replace(/\/$/, "");
        while (true) {
          if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
          const pollUrl = `${base}/${encodeURIComponent(responseId)}`;
          const pollResp = await fetch(pollUrl, { signal });
          const { parsed, ok, status } = await parseResponseBody(pollResp);

          if (!ok) {
            const err =
              (parsed && parsed.error) ||
              (typeof parsed === "string" ? parsed : null) ||
              `Polling failed with status ${status}`;
            throw new Error(err);
          }

          const currentStatus =
            (parsed && parsed.status) ||
            (parsed && parsed.response && parsed.response.status) ||
            "pending";
          const normalizedStatus = normalizeStatus(currentStatus) || "pending";

          showStatus(`Background run status: ${normalizedStatus}`);
          if (typeof onStatus === "function") onStatus(normalizedStatus, parsed);

          if (
            (parsed && parsed.done) ||
            ["completed", "failed", "cancelled"].includes(normalizedStatus)
          ) {
            return parsed;
          }

          await sleep(POLL_INTERVAL_MS, signal);
        }
      };

      const buildMessageRow = (role = "user", text = "") => {
        const normalizedRole = normalizeRole(role);
        const row = document.createElement("div");
        row.className = "message-row";

        const header = document.createElement("div");
        header.className = "row-header";

        const label = document.createElement("label");
        label.textContent = "Role";

        const select = document.createElement("select");
        select.append(
          createOption("developer", "Developer", normalizedRole === "developer"),
          createOption("user", "User", normalizedRole === "user"),
          createOption("assistant", "Assistant", normalizedRole === "assistant")
        );

        const actions = document.createElement("div");
        actions.className = "row-actions";

        const copyBtn = document.createElement("button");
        copyBtn.type = "button";
        copyBtn.className = "ghost small";
        copyBtn.textContent = "Copy";

        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.className = "ghost small";
        removeBtn.textContent = "Remove";

        actions.append(copyBtn, removeBtn);
        header.append(label, select, actions);

        const textarea = document.createElement("textarea");
        textarea.placeholder = ROLE_PLACEHOLDERS[normalizedRole];
        textarea.value = text;

        select.addEventListener("change", () => {
          const nextRole = normalizeRole(select.value);
          textarea.placeholder = ROLE_PLACEHOLDERS[nextRole] || "";
        });

        copyBtn.addEventListener("click", () => copyText(textarea.value, copyBtn));

        removeBtn.addEventListener("click", () => {
          if (messagesContainer.children.length <= 1) {
            showStatus("At least one message is required.", "error");
            return;
          }
          row.remove();
        });

        row.append(header, textarea);
        return row;
      };

      const addMessageRow = (role = "user", text = "") => {
        const row = buildMessageRow(normalizeRole(role), text);
        messagesContainer.appendChild(row);
        return row;
      };

      const resetAgenticState = () => {
        agenticState.active = false;
        agenticState.workflowType = null;
        agenticState.queue = [];
        agenticState.loopCount = 0;
        agenticState.error = null;
        agenticState.completed = false;
        agenticState.lastStage = null;
        agenticState.lastOrchestrator = null;
        agenticState.running = false;
        agenticState.stopRequested = false;
      };

      const clearAllFields = () => {
        hideWorkflowPrompt();
        clearAutoAdvanceTimer();
        clearBackgroundRunState();
        resetAgenticState();

        messagesContainer.innerHTML = "";
        addMessageRow("developer");
        addMessageRow("user");

        if (stateFilenameInput) stateFilenameInput.value = DEFAULT_STATE_FILENAME;
        if (autoRunAgenticCheckbox) autoRunAgenticCheckbox.checked = false;
        if (autoLoopLimitInput) autoLoopLimitInput.value = String(DEFAULT_AUTO_LOOP_LIMIT);
        syncAutoRunControls();
        if (outputBox) outputBox.value = "";
        if (payloadBox) payloadBox.value = "";
        if (fullResponseBox) fullResponseBox.value = "";
        if (orchestratorJson) orchestratorJson.value = "";
        renderOrchestratorPlaceholder("Rendered orchestrator output will appear here.");
        setResponseId("");
        showStatus("Cleared all fields.", "success");
        refreshSnapshotList({ silent: true });
        updateStopButtonState();
      };

      const stopWorkflow = async (options = {}) => {
        const { silent = false } = options;
        const hasPendingAutoAdvance = Boolean(autoAdvanceTimer);
        const isRunning = Boolean(agenticState.running || currentBackgroundRun?.responseId);
        if (!isRunning && !hasPendingAutoAdvance) {
          if (!silent) showStatus("Workflow is not running.", "error");
          return false;
        }

        agenticState.stopRequested = true;
        clearAutoAdvanceTimer();
        hideWorkflowPrompt();
        if (!silent) showStatus("Stopping workflow…");

        if (currentBackgroundRun?.responseId) {
          const cancelled = await cancelBackgroundTask({ silent: true, force: true });
          if (!cancelled && !silent) {
            showStatus(
              "Failed to cancel background task. Workflow paused locally.",
              "error"
            );
          }
          if (currentBackgroundRun) {
            currentBackgroundRun.cancelInFlight = true;
            if (currentBackgroundRun.controller) {
              currentBackgroundRun.controller.abort();
            }
          }
        }
        if (currentStageController) {
          try {
            currentStageController.abort();
          } catch (error) {
            console.warn("Failed to abort stage request", error);
          }
        }

        if (!agenticState.running) {
          agenticState.stopRequested = false;
          if (!silent) showStatus("Workflow stopped. Resume to continue.", "success");
          await saveAgenticState("stopped", { silent: true });
          updateStopButtonState();
        }
        return true;
      };

      addMessageBtn.addEventListener("click", () => addMessageRow("user"));
      addAssistantBtn.addEventListener("click", () => addMessageRow("assistant"));
      addAssistantFromOutputBtn.addEventListener("click", () => {
        const text = outputBox.value || "";
        const row = buildMessageRow("assistant", text);
        messagesContainer.appendChild(row);
      });
      clearAllFieldsBtn?.addEventListener("click", () => clearAllFields());
      forkConversationBtn?.addEventListener("click", () => {
        const rows = Array.from(messagesContainer.querySelectorAll(".message-row"));
        if (!rows.length) {
          showStatus("Add at least one message before forking.", "error");
          return;
        }

        const messages = collectConversationMessages();
        const storageKey = `fork-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        try {
          localStorage.setItem(storageKey, JSON.stringify(messages));
        } catch (error) {
          console.error("Fork storage error", error);
          showStatus("Unable to store forked conversation (storage blocked).", "error");
          return;
        }

        const url = new URL(window.location.href);
        url.searchParams.set("forkKey", storageKey);

        const anchor = document.createElement("a");
        anchor.href = url.toString();
        anchor.target = "_blank";
        anchor.rel = "noopener";
        anchor.style.display = "none";
        document.body.appendChild(anchor);
        anchor.click();
        anchor.remove();

        showStatus("Opening forked conversation in a new tab.", "success");
      });
      copyInputsBtn.addEventListener("click", async () => {
        const inputs = Array.from(messagesContainer.querySelectorAll(".message-row textarea"));
        if (!inputs.length) {
          showStatus("Add at least one message before copying.", "error");
          return;
        }
        const combined = inputs.map((el) => el.value || "").join("\n\n");
        const copied = await copyText(combined, copyInputsBtn);
        if (copied) showStatus("Copied input messages.", "success");
      });
      copyInputsSkipFirstBtn.addEventListener("click", async () => {
        const inputs = Array.from(messagesContainer.querySelectorAll(".message-row textarea"));
        if (inputs.length <= 1) {
          showStatus("Add at least two messages before copying without the first one.", "error");
          return;
        }
        const combined = inputs.slice(1).map((el) => el.value || "").join("\n\n");
        const copied = await copyText(combined, copyInputsSkipFirstBtn);
        if (copied) showStatus("Copied input messages (excluding first).", "success");
      });
      copyOutputBtn.addEventListener("click", () => copyText(outputBox.value, copyOutputBtn));
      copyPayloadBtn.addEventListener("click", () => copyText(payloadBox.value, copyPayloadBtn));
      copyFullResponseBtn.addEventListener("click", () =>
        copyText(fullResponseBox.value, copyFullResponseBtn)
      );
      copyOrchestratorJsonBtn?.addEventListener("click", () =>
        copyText(orchestratorJson?.value || "", copyOrchestratorJsonBtn)
      );
      refreshSnapshotsBtn?.addEventListener("click", () => refreshSnapshotList());
      rollbackSnapshotBtn?.addEventListener("click", () => rollbackToSnapshot());
      resumeSnapshotBtn?.addEventListener("click", () => resumeFromSnapshot());
      stateFilenameInput?.addEventListener("change", () => refreshSnapshotList({ silent: true }));
      workflowPromptYes?.addEventListener("click", () => {
        const handler = workflowPromptConfig?.onYes;
        hideWorkflowPrompt();
        if (typeof handler === "function") handler();
      });
      workflowPromptNo?.addEventListener("click", () => {
        const handler = workflowPromptConfig?.onNo;
        hideWorkflowPrompt();
        if (typeof handler === "function") handler();
      });
      cancelBackgroundBtn?.addEventListener("click", () => cancelBackgroundTask());

      const disableForm = (disabled) => {
        form.querySelectorAll("textarea, button, select").forEach((el) => {
          if (
            el === copyOutputBtn ||
            el === copyPayloadBtn ||
            el === copyFullResponseBtn ||
            el === cancelBackgroundBtn ||
            el === saveWorkflowBtn ||
            el === copyOrchestratorJsonBtn ||
            el === stopWorkflowBtn
          )
            return; // keep copy/cancel available
          el.disabled = disabled;
        });
      };

      const handleForegroundRequest = async (payload, options = {}) => {
        const { signal } = options;
        const endpoint = form.dataset.endpoint || "/api/prompt-run";
        let response;
        try {
          response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            signal,
          });
        } catch (error) {
          if (isAbortError(error)) {
            return { aborted: true };
          }
          throw error;
        }

        const { parsed, ok, status } = await parseResponseBody(response);

        if (!ok) {
          const err =
            (parsed && parsed.error) ||
            (typeof parsed === "string" ? parsed : null) ||
            `Request failed with status ${status}`;
          showStatus(err, "error");
          outputBox.value = "";
          if (fullResponseBox) fullResponseBox.value = "";
          return { error: err };
        }

        showStatus("Received response from OpenAI.", "success");
        const extractedText = extractOutputText(parsed);
        const pretty =
          typeof parsed === "object"
            ? JSON.stringify(parsed.response || parsed, null, 2)
            : String(parsed);
        outputBox.value = extractedText || "";
        if (fullResponseBox) fullResponseBox.value = pretty || "";
        return { payload: parsed, outputText: extractedText };
      };

      const handleBackgroundRequest = async (payload, options = {}) => {
        const { signal, endpoints = {} } = options;
        const endpoint =
          endpoints.start || form.dataset.backgroundEndpoint || "/api/prompt-run-background";
        const pollBase = endpoints.poll || form.dataset.backgroundPollEndpoint || endpoint;
        const cancelBase =
          endpoints.cancel || form.dataset.backgroundCancelEndpoint || pollBase || endpoint;
        let response;
        try {
          response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            signal,
          });
        } catch (error) {
          if (isAbortError(error)) {
            return { aborted: true };
          }
          throw error;
        }

        const { parsed, ok, status } = await parseResponseBody(response);

        if (!ok) {
          const err =
            (parsed && parsed.error) ||
            (typeof parsed === "string" ? parsed : null) ||
            `Request failed with status ${status}`;
          showStatus(err, "error");
          return { error: err };
        }

        const responseId = parsed.response_id || (parsed.response && parsed.response.id);
        if (!responseId) {
          showStatus("No response ID returned for background job.", "error");
          return;
        }

        const startingStatus =
          parsed.status || (parsed.response && parsed.response.status) || "queued";
        const normalizedStart = normalizeStatus(startingStatus) || startingStatus;
        setResponseId(responseId);
        showStatus(
          `Background run started (${normalizedStart}). response_id: ${responseId}. Polling for completion…`
        );

        currentBackgroundRun = {
          responseId,
          controller: new AbortController(),
          cancelInFlight: false,
          lastStatus: normalizedStart,
          cancelEndpointBase: cancelBase,
          pollEndpointBase: pollBase,
        };
        updateCancelButton(normalizedStart);
        updateStopButtonState();

        let finalPayload;
        try {
          finalPayload = await pollForCompletion(responseId, pollBase, {
            signal: currentBackgroundRun.controller.signal,
            onStatus: (status) => markBackgroundStatus(status),
          });
        } catch (error) {
          if (isAbortError(error) && currentBackgroundRun?.cancelInFlight) {
            clearBackgroundRunState();
            return { aborted: true };
          }
          clearBackgroundRunState();
          throw error;
        }

        const finalStatusRaw =
          (finalPayload && finalPayload.status) ||
          (finalPayload && finalPayload.response && finalPayload.response.status) ||
          "unknown";
        const finalStatus = normalizeStatus(finalStatusRaw) || finalStatusRaw || "unknown";
        const extractedText = extractOutputText(finalPayload);
        const pretty =
          typeof finalPayload === "object"
            ? JSON.stringify(finalPayload.response || finalPayload, null, 2)
            : String(finalPayload);
        outputBox.value = extractedText || "";
        if (fullResponseBox) fullResponseBox.value = pretty || "";

        const statusType =
          finalStatus === "completed" ? "success" : finalStatus === "failed" ? "error" : "";
        showStatus(`Background run finished with status: ${finalStatus}`, statusType);
        clearBackgroundRunState();
        return { payload: finalPayload, outputText: extractedText };
      };

      const buildRequestPayload = (overrideSettings = null) => {
        const rows = Array.from(messagesContainer.querySelectorAll(".message-row"));
        if (!rows.length) {
          throw new Error("Add at least one message before sending.");
        }

        const messages = [];
        for (const row of rows) {
          const select = row.querySelector("select");
          const textarea = row.querySelector("textarea");
          const role = select?.value;
          const text = textarea?.value?.trim();
          if (!role || !text) {
            throw new Error("Every message needs a role and text.");
          }
          const type = role === "assistant" ? "output_text" : "input_text";
          messages.push({ role, content: [{ type, text }] });
        }

        const baseSettings = getSettingsSnapshot();
        const resolvedSettings = overrideSettings
          ? { ...baseSettings, ...overrideSettings }
          : baseSettings;
        const model = resolvedSettings.model || "gpt-5.1";
        const backgroundMode = Boolean(resolvedSettings.background);
        const reasoningEffort = resolvedSettings.reasoning_effort || "high";
        const textVerbosity = resolvedSettings.text_verbosity || "high";

        return {
          payload: {
            messages,
            model,
            background: backgroundMode,
            reasoning_effort: reasoningEffort,
            text_verbosity: textVerbosity,
          },
          settings: {
            model,
            backgroundMode,
            reasoningEffort,
            textVerbosity,
          },
          messages,
        };
      };

      const buildPayloadForDisplay = (messages, settings, formatType = "text") => {
        const textConfig = { format: { type: formatType } };
        if (formatType === "json_schema") {
          textConfig.format.name = "orchestrator_decision";
          textConfig.format.strict = true;
        }
        textConfig.verbosity = settings.textVerbosity;

        const reasoningConfig = { summary: null };
        reasoningConfig.effort = settings.reasoningEffort;

        const payloadForDisplay = {
          model: settings.model,
          input: messages,
          text: textConfig,
          reasoning: reasoningConfig,
          tools: [
            {
              type: "web_search",
              user_location: { type: "approximate" },
              search_context_size: "high",
            },
          ],
        };
        if (settings.backgroundMode) {
          payloadForDisplay.background = true;
        } else {
          payloadForDisplay.store = true;
        }
        return payloadForDisplay;
      };

      const updatePayloadBox = (messages, settings, formatType = "text") => {
        payloadBox.value = JSON.stringify(
          buildPayloadForDisplay(messages, settings, formatType),
          null,
          2
        );
      };

      const handleOrchestratorForegroundRequest = async (payload, options = {}) => {
        const { signal } = options;
        const endpoint = "/api/orchestrator-run";
        let response;
        try {
          response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            signal,
          });
        } catch (error) {
          if (isAbortError(error)) {
            return { aborted: true };
          }
          throw error;
        }

        const { parsed, ok, status } = await parseResponseBody(response);
        if (!ok) {
          const err =
            (parsed && parsed.error) ||
            (typeof parsed === "string" ? parsed : null) ||
            `Request failed with status ${status}`;
          showStatus(err, "error");
          outputBox.value = "";
          if (fullResponseBox) fullResponseBox.value = "";
          return { error: err };
        }

        const outputTexts = Array.isArray(parsed.output_texts) ? parsed.output_texts : [];
        outputBox.value = outputTexts.join("\n\n").trim();
        if (fullResponseBox) {
          fullResponseBox.value = parsed.response ? JSON.stringify(parsed.response, null, 2) : "";
        }
        showStatus("Received orchestrator response.", "success");
        return parsed;
      };

      const handleOrchestratorBackgroundRequest = async (payload, options = {}) => {
        const { signal } = options;
        const endpoint = "/api/orchestrator-run-background";
        const pollBase = "/api/orchestrator-run-background";
        let response;
        try {
          response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            signal,
          });
        } catch (error) {
          if (isAbortError(error)) {
            return { aborted: true };
          }
          throw error;
        }

        const { parsed, ok, status } = await parseResponseBody(response);

        if (!ok) {
          const err =
            (parsed && parsed.error) ||
            (typeof parsed === "string" ? parsed : null) ||
            `Request failed with status ${status}`;
          showStatus(err, "error");
          return { error: err };
        }

        const responseId = parsed.response_id || (parsed.response && parsed.response.id);
        if (!responseId) {
          showStatus("No response ID returned for background job.", "error");
          return null;
        }

        const startingStatus =
          parsed.status || (parsed.response && parsed.response.status) || "queued";
        const normalizedStart = normalizeStatus(startingStatus) || startingStatus;
        setResponseId(responseId);
        showStatus(
          `Background orchestrator started (${normalizedStart}). response_id: ${responseId}. Polling for completion…`
        );

        currentBackgroundRun = {
          responseId,
          controller: new AbortController(),
          cancelInFlight: false,
          lastStatus: normalizedStart,
          cancelEndpointBase: pollBase,
          pollEndpointBase: pollBase,
        };
        updateCancelButton(normalizedStart);
        updateStopButtonState();

        let finalPayload;
        try {
          finalPayload = await pollForCompletion(responseId, pollBase, {
            signal: currentBackgroundRun.controller.signal,
            onStatus: (statusText) => markBackgroundStatus(statusText),
          });
        } catch (error) {
          if (isAbortError(error) && currentBackgroundRun?.cancelInFlight) {
            clearBackgroundRunState();
            return { aborted: true };
          }
          clearBackgroundRunState();
          throw error;
        }

        const finalStatusRaw = finalPayload?.status || "unknown";
        const finalStatus = normalizeStatus(finalStatusRaw) || finalStatusRaw || "unknown";
        const outputTexts = Array.isArray(finalPayload.output_texts) ? finalPayload.output_texts : [];
        outputBox.value = outputTexts.join("\n\n").trim();
        if (fullResponseBox) {
          fullResponseBox.value = finalPayload.response
            ? JSON.stringify(finalPayload.response, null, 2)
            : "";
        }

        const statusType =
          finalStatus === "completed" ? "success" : finalStatus === "failed" ? "error" : "";
        showStatus(`Background orchestrator finished with status: ${finalStatus}`, statusType);
        clearBackgroundRunState();
        return finalPayload;
      };

      const getMessageRows = () =>
        Array.from(messagesContainer.querySelectorAll(".message-row"));

      const setRowRole = (row, role) => {
        const normalized = normalizeRole(role);
        const select = row.querySelector("select");
        const textarea = row.querySelector("textarea");
        if (select) {
          select.value = normalized;
          select.dispatchEvent(new Event("change"));
        }
        if (textarea) {
          textarea.placeholder = ROLE_PLACEHOLDERS[normalized] || "";
        }
      };

      const pruneToFirstTwoRows = () => {
        const rows = getMessageRows();
        rows.slice(2).forEach((row) => row.remove());
      };

      const validateProblemInput = () => {
        const rows = getMessageRows();
        if (rows.length < 2) {
          showStatus("A developer message and user problem statement are required.", "error");
          return null;
        }
        const devRow = rows[0];
        const userRow = rows[1];
        setRowRole(devRow, "developer");
        setRowRole(userRow, "user");
        const userText = userRow.querySelector("textarea")?.value?.trim() || "";
        if (!userText) {
          showStatus("User problem statement is required.", "error");
          return null;
        }
        if (!KEYWORD_REGEX.test(userText)) {
          showStatus(
            "User input must include the keyword problem, question, or research.",
            "error"
          );
          return null;
        }
        return { devRow, userRow, userText };
      };

      const appendUserMessage = (text) => {
        if (!text) return;
        addMessageRow("user", text);
      };

      const beginStageRequest = () => {
        if (currentStageController) {
          try {
            currentStageController.abort();
          } catch (error) {
            console.warn("Failed to abort previous stage request", error);
          }
        }
        currentStageController = new AbortController();
        return currentStageController;
      };

      const clearStageRequest = (controller) => {
        if (currentStageController === controller) {
          currentStageController = null;
        }
      };

      const shouldRetryError = (error) => {
        if (isAbortError(error)) return false;
        if (error && error.retryable === false) return false;
        return true;
      };

      const runStageWithAutoRetry = async (stage, runner) => {
        const stageLabel = AGENTIC_STAGES[stage]?.label || stage;
        const allowRetry = getAutoRunEnabled();
        let attempts = 0;

        while (true) {
          if (agenticState.stopRequested) {
            throw new DOMException("Aborted", "AbortError");
          }
          try {
            return await runner();
          } catch (error) {
            if (!allowRetry || !shouldRetryError(error)) {
              throw error;
            }
            if (attempts >= AUTO_RETRY_LIMIT) {
              if (error && typeof error === "object") {
                error.retry_exhausted = true;
              }
              throw error;
            }
            attempts += 1;
            showStatus(`Autonomous mode: ${stageLabel} failed. Retrying once…`, "error");
          }
        }
      };

      const runAgentStage = async (stage) => {
        const stageInfo = AGENTIC_STAGES[stage];
        if (!stageInfo) throw new Error(`Unknown stage: ${stage}`);
        showStatus(`Running ${stageInfo.label}…`);
        const content = await fetchSystemMessage(stageInfo.key);
        replaceFirstMessageWithContent(content);

        const { payload, settings, messages } = buildRequestPayload(resolveStageSettings(stage));
        updatePayloadBox(messages, settings, "text");

        const controller = beginStageRequest();
        try {
          const result = payload.background
            ? await handleBackgroundRequest(payload, { signal: controller.signal })
            : await handleForegroundRequest(payload, { signal: controller.signal });
          if (result?.aborted) {
            throw new DOMException("Aborted", "AbortError");
          }
          if (result?.error) {
            throw new Error(result.error);
          }
          if (!result || !result.outputText) {
            throw new Error("No assistant output returned.");
          }
          appendUserMessage(result.outputText);
          return result.outputText;
        } finally {
          clearStageRequest(controller);
        }
      };

      const runOrchestratorStage = async () => {
        const stageInfo = AGENTIC_STAGES.orchestrator;
        showStatus(`Running ${stageInfo.label}…`);
        const content = await fetchSystemMessage(stageInfo.key);
        replaceFirstMessageWithContent(content);

        const { payload, settings, messages } = buildRequestPayload(
          resolveStageSettings("orchestrator")
        );
        updatePayloadBox(messages, settings, "json_schema");

        const controller = beginStageRequest();
        try {
          const result = payload.background
            ? await handleOrchestratorBackgroundRequest(payload, { signal: controller.signal })
            : await handleOrchestratorForegroundRequest(payload, { signal: controller.signal });
          if (result?.aborted) {
            throw new DOMException("Aborted", "AbortError");
          }
          if (result?.error) {
            throw new Error(result.error);
          }
          if (!result) {
            throw new Error("No orchestrator response returned.");
          }

          const parsedOutputs = Array.isArray(result.parsed_outputs) ? result.parsed_outputs : [];
          const parseErrors = Array.isArray(result.parse_errors) ? result.parse_errors : [];
          if (parseErrors.length) {
            const parseError = new Error(
              `Orchestrator JSON parse error: ${parseErrors.join(" | ")}`
            );
            parseError.retryable = false;
            throw parseError;
          }
          if (!parsedOutputs.length) {
            throw new Error("Orchestrator returned no parsed JSON output.");
          }
          const rawText = Array.isArray(result.output_texts)
            ? result.output_texts.join("\n\n")
            : "";
          setOrchestratorOutput(parsedOutputs[0], rawText);
          return parsedOutputs[0];
        } finally {
          clearStageRequest(controller);
        }
      };

      const promptToContinue = (nextStage) => {
        const nextLabel = AGENTIC_STAGES[nextStage]?.label || "next stage";
        if (getAutoRunEnabled()) {
          scheduleAutoAdvance(
            `Autonomous mode: continuing to ${nextLabel}…`,
            () => runNextStage()
          );
          return;
        }
        showWorkflowPrompt({
          title: "Continue workflow?",
          message: `Agent output captured. Save if needed. Proceed to ${nextLabel}?`,
          yesLabel: "Yes",
          noLabel: "No",
          onYes: () => runNextStage(),
          onNo: async () => {
            const saved = await saveAgenticState("paused", { silent: true });
            showStatus(
              saved
                ? "Workflow paused and saved. Use Resume to continue."
                : "Workflow paused. Save failed.",
              saved ? "success" : "error"
            );
          },
        });
      };

      const promptForLoop = (action) => {
        const maxLoops = getAutoLoopLimit();
        const autoRunEnabled = getAutoRunEnabled();
        const nextLoopNumber = agenticState.loopCount + 1;
        const onYes = () => {
          agenticState.queue = [...LOOP_QUEUE];
          runNextStage();
        };
        const onNo = async () => {
          agenticState.completed = true;
          agenticState.active = false;
          const saved = await saveAgenticState("ended", { silent: true });
          showStatus(
            saved ? "Workflow ended by user. State saved." : "Workflow ended by user.",
            "success"
          );
        };

        if (autoRunEnabled && agenticState.loopCount < maxLoops) {
          scheduleAutoAdvance(
            `Autonomous mode: starting solver loop ${nextLoopNumber} of ${maxLoops}…`,
            onYes
          );
          return;
        }

        if (autoRunEnabled && agenticState.loopCount >= maxLoops) {
          showStatus(
            `Auto-run loop limit reached (${maxLoops}). Awaiting manual choice.`
          );
        }

        const limitNote =
          autoRunEnabled && agenticState.loopCount >= maxLoops
            ? ` Auto-run limit reached (${maxLoops}).`
            : "";
        showWorkflowPrompt({
          title: "Run another solver loop?",
          message: `Orchestrator action: ${action || "DISPATCH"}. Run another Solver/Evaluator loop or end?${limitNote}`,
          yesLabel: "Run loop",
          noLabel: "End process",
          onYes,
          onNo,
        });
      };

      const runNextStage = async () => {
        if (agenticState.running) {
          showStatus("Workflow already running.", "error");
          return;
        }
        if (agenticState.stopRequested) {
          agenticState.stopRequested = false;
          showStatus("Workflow stopped. Resume to continue.", "success");
          await saveAgenticState("stopped", { silent: true });
          updateStopButtonState();
          return;
        }
        const stage = agenticState.queue[0];
        if (!stage) {
          agenticState.completed = true;
          agenticState.active = false;
          showStatus("Workflow complete.", "success");
          return;
        }

        agenticState.running = true;
        agenticState.error = null;
        hideWorkflowPrompt();
        disableForm(true);
        updateStopButtonState();

        try {
          if (stage === "orchestrator") {
            const parsed = await runStageWithAutoRetry(stage, () => runOrchestratorStage());
            agenticState.queue.shift();
            agenticState.lastStage = stage;
            agenticState.loopCount += 1;
            agenticState.error = null;
            await saveAgenticState("orchestrator-complete");

            const action = parsed?.action;
            if (action === "FINAL" || action === "ASK_USER") {
              agenticState.completed = true;
              agenticState.active = false;
              showStatus(`Workflow completed (action: ${action}).`, "success");
              return;
            }
            promptForLoop(action);
            return;
          }

          await runStageWithAutoRetry(stage, () => runAgentStage(stage));
          agenticState.queue.shift();
          agenticState.lastStage = stage;
          agenticState.error = null;

          const nextStage = agenticState.queue[0];
          if (!nextStage) {
            agenticState.completed = true;
            agenticState.active = false;
            showStatus("Workflow complete.", "success");
            return;
          }
          promptToContinue(nextStage);
        } catch (error) {
          if (isAbortError(error) || agenticState.stopRequested) {
            agenticState.stopRequested = false;
            agenticState.error = null;
            showStatus("Workflow stopped. Resume to continue.", "success");
            await saveAgenticState("stopped", { silent: true });
            return;
          }
          const message = error && error.message ? error.message : "Unknown error";
          agenticState.error = { stage, message };
          if (error && error.retry_exhausted && getAutoRunEnabled()) {
            showStatus(
              `Autonomous mode: ${AGENTIC_STAGES[stage]?.label || stage} failed twice. Workflow stopped.`,
              "error"
            );
            await saveAgenticState("auto-retry-stopped", { silent: true });
            return;
          }
          showStatus(`${AGENTIC_STAGES[stage]?.label || stage} failed: ${message}`, "error");
          await saveAgenticState("error", { silent: true });
        } finally {
          agenticState.running = false;
          disableForm(false);
          updateStopButtonState();
        }
      };

      const getNextStageLabel = () => {
        const stage = agenticState.queue[0];
        return AGENTIC_STAGES[stage]?.label || stage || "next stage";
      };

      const promptForResume = (sourceLabel, onConfirm) => {
        const nextStage = agenticState.queue[0];
        if (!nextStage) {
          showStatus("No pending workflow stage to resume.", "error");
          return;
        }
        showWorkflowPrompt({
          title: "Resume workflow?",
          message: `${sourceLabel} Next agent: ${getNextStageLabel()}. Proceed?`,
          yesLabel: "Resume",
          noLabel: "Cancel",
          onYes: () => {
            hideWorkflowPrompt();
            if (typeof onConfirm === "function") onConfirm();
          },
          onNo: () => {
            showStatus("Resume cancelled.", "success");
          },
        });
      };

      const startAgenticWorkflow = async (type) => {
        if (agenticState.running) {
          showStatus("Workflow already running.", "error");
          return;
        }
        hideWorkflowPrompt();
        clearAutoAdvanceTimer();
        const validation = validateProblemInput();
        if (!validation) return;
        pruneToFirstTwoRows();

        agenticState.active = true;
        agenticState.workflowType = type;
        agenticState.queue = [...(INITIAL_QUEUES[type] || [])];
        agenticState.loopCount = 0;
        agenticState.error = null;
        agenticState.completed = false;
        agenticState.lastStage = null;
        agenticState.lastOrchestrator = null;
        agenticState.stopRequested = false;
        if (orchestratorJson) orchestratorJson.value = "";
        renderOrchestratorPlaceholder("Rendered orchestrator output will appear here.");

        await runNextStage();
      };

      const resumeAgenticWorkflow = async () => {
        if (agenticState.running) {
          showStatus("Workflow already running.", "error");
          return;
        }
        hideWorkflowPrompt();
        clearAutoAdvanceTimer();
        try {
          showStatus("Loading saved workflow state…");
          const state = await loadAgenticState();
          applyStateSnapshot(state);
          await refreshSnapshotList({ silent: true });
          showStatus("Saved workflow state restored.", "success");
        } catch (error) {
          console.error("Resume error", error);
          showStatus(
            `Resume failed: ${error && error.message ? error.message : "Unknown error"}`,
            "error"
          );
          return;
        }

        if (agenticState.completed) {
          showStatus("Workflow already completed.", "success");
          return;
        }
        if (!agenticState.queue.length) {
          showStatus("No pending workflow stage to resume.", "error");
          return;
        }

        agenticState.stopRequested = false;
        promptForResume("Saved workflow state restored.", () => runNextStage());
      };

      const rollbackToSnapshot = async () => {
        if (!snapshotSelect) return;
        const snapshotName = snapshotSelect.value;
        if (!snapshotName) {
          showStatus("Select a snapshot to roll back.", "error");
          return;
        }
        if (agenticState.running) {
          showStatus("Stop the workflow before rolling back.", "error");
          return;
        }
        hideWorkflowPrompt();
        clearAutoAdvanceTimer();
        try {
          showStatus("Loading snapshot…");
          const snapshotState = await loadSnapshotState(snapshotName);
          applyStateSnapshot(snapshotState);
          const saved = await saveAgenticState("rollback", { createSnapshot: true, silent: true });
          showStatus(
            saved
              ? "Rollback complete. Workflow state saved."
              : "Rollback loaded, but saving the state failed.",
            saved ? "success" : "error"
          );
        } catch (error) {
          console.error("Rollback error", error);
          showStatus(
            `Rollback failed: ${error && error.message ? error.message : "Unknown error"}`,
            "error"
          );
        }
      };

      const resumeFromSnapshot = async () => {
        if (!snapshotSelect) return;
        const snapshotName = snapshotSelect.value;
        if (!snapshotName) {
          showStatus("Select a snapshot to resume.", "error");
          return;
        }
        if (agenticState.running) {
          showStatus("Stop the workflow before resuming from a snapshot.", "error");
          return;
        }
        hideWorkflowPrompt();
        clearAutoAdvanceTimer();
        try {
          showStatus("Loading snapshot…");
          const snapshotState = await loadSnapshotState(snapshotName);
          applyStateSnapshot(snapshotState);
          await refreshSnapshotList({ silent: true });
          agenticState.stopRequested = false;
          promptForResume(`Snapshot loaded (${snapshotName}).`, async () => {
            await saveAgenticState("resume-from-snapshot", { silent: true });
            runNextStage();
          });
        } catch (error) {
          console.error("Resume from snapshot error", error);
          showStatus(
            `Resume from snapshot failed: ${error && error.message ? error.message : "Unknown error"}`,
            "error"
          );
        }
      };

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        showStatus("");

        const rows = Array.from(messagesContainer.querySelectorAll(".message-row"));
        if (!rows.length) {
          showStatus("Add at least one message before sending.", "error");
          return;
        }

        const messages = [];
        for (const row of rows) {
          const select = row.querySelector("select");
          const textarea = row.querySelector("textarea");
          const role = select?.value;
          const text = textarea?.value?.trim();
          if (!role || !text) {
            showStatus("Every message needs a role and text.", "error");
            return;
          }
          const type = role === "assistant" ? "output_text" : "input_text";
          messages.push({ role, content: [{ type, text }] });
        }

        const model = modelSelect?.value || "gpt-5.1";
        const backgroundMode = (backgroundSelect?.value || "false") === "true";
        const reasoningEffort = effortSelect?.value || "high";
        const textVerbosity = verbositySelect?.value || "high";

        const payload = {
          messages,
          model,
          background: backgroundMode,
          reasoning_effort: reasoningEffort,
          text_verbosity: textVerbosity,
        };

        const textConfig = { format: { type: "text" } };
        textConfig.verbosity = textVerbosity;

        const reasoningConfig = { summary: null };
        reasoningConfig.effort = reasoningEffort;

        const payloadForDisplay = {
          model,
          input: messages,
          text: textConfig,
          reasoning: reasoningConfig,
          tools: [
            {
              type: "web_search",
              user_location: { type: "approximate" },
              search_context_size: "high",
            },
          ],
        };
        if (backgroundMode) {
          payloadForDisplay.background = true;
        } else {
          payloadForDisplay.store = true;
        }
        payloadBox.value = JSON.stringify(payloadForDisplay, null, 2);

        outputBox.value = "";
        if (fullResponseBox) fullResponseBox.value = "";
        setResponseId("");

        disableForm(true);
        showStatus(backgroundMode ? "Starting background request…" : "Sending request…");

        try {
          if (backgroundMode) {
            await handleBackgroundRequest(payload);
          } else {
            await handleForegroundRequest(payload);
          }
        } catch (error) {
          console.error("Network error", error);
          showStatus(`Network error: ${error.message}`, "error");
          outputBox.value = "";
          if (fullResponseBox) fullResponseBox.value = "";
          setResponseId("");
        } finally {
          disableForm(false);
        }
      });

      const getPrefillKey = () => {
        const params = new URLSearchParams(window.location.search);
        return params.get("prefillKey");
      };

      const getForkKeyFromQuery = () => {
        const params = new URLSearchParams(window.location.search);
        return params.get("forkKey");
      };

      const fetchSystemMessage = async (key) => {
        const response = await fetch(`/api/system-message/${encodeURIComponent(key)}`);
        let data;
        try {
          data = await response.json();
        } catch (error) {
          throw new Error("Invalid response while loading system message.");
        }
        if (!response.ok || !data?.ok || typeof data.content !== "string") {
          const err = (data && data.error) || `Failed to load system message: ${key}`;
          throw new Error(err);
        }
        return data.content;
      };

      const ensureFirstMessageRow = () => {
        let row = messagesContainer.querySelector(".message-row");
        if (!row) {
          row = addMessageRow("developer");
        }
        return row;
      };

      const replaceFirstMessageWithContent = (content) => {
        const row = ensureFirstMessageRow();
        const select = row.querySelector("select");
        const textarea = row.querySelector("textarea");
        if (select) {
          select.value = "developer";
          select.dispatchEvent(new Event("change"));
        }
        if (textarea) {
          textarea.value = content;
        }
      };

      const wireLoaderButton = (button, key, label) => {
        if (!button) return;
        button.addEventListener("click", async () => {
          try {
            showStatus(`Loading ${label} message…`);
            const content = await fetchSystemMessage(key);
            replaceFirstMessageWithContent(content);
            showStatus(`${label} message loaded into first input.`, "success");
          } catch (error) {
            console.error("System message load failed", error);
            const message =
              (error && error.message) || `Failed to load ${label.toLowerCase()} message.`;
            showStatus(message, "error");
          }
        });
      };

      const applyDeveloperPrefill = async (row) => {
        const key = getPrefillKey();
        if (!key) return;
        const textarea = row.querySelector("textarea");
        if (!textarea) return;
        try {
          showStatus(`Loading developer prefill for ${key}…`);
          const content = await fetchSystemMessage(key);
          textarea.value = content;
          showStatus(`Loaded developer prefill for ${key}.`, "success");
        } catch (error) {
          console.error("Developer prefill failed", error);
          showStatus(error.message || "Failed to load developer prefill.", "error");
        }
      };

      const applyForkedConversation = () => {
        const forkKey = getForkKeyFromQuery();
        if (!forkKey) return false;

        const stored = localStorage.getItem(forkKey);
        if (!stored) {
          showStatus("Forked conversation unavailable or expired.", "error");
          return false;
        }

        let messages;
        try {
          messages = JSON.parse(stored);
        } catch (error) {
          console.error("Forked conversation parse error", error);
          showStatus("Failed to load forked conversation data.", "error");
          return false;
        }

        if (!Array.isArray(messages) || !messages.length) {
          showStatus("Forked conversation had no messages.", "error");
          return false;
        }

        messagesContainer.innerHTML = "";
        messages.forEach((entry) => {
          const role = normalizeRole(entry?.role || "user");
          const text = typeof entry?.text === "string" ? entry.text : "";
          addMessageRow(role, text);
        });

        showStatus("Forked conversation loaded from previous tab.", "success");
        try {
          localStorage.removeItem(forkKey);
        } catch (error) {
          console.warn("Could not remove forked conversation key", error);
        }
        try {
          const url = new URL(window.location.href);
          url.searchParams.delete("forkKey");
          window.history.replaceState({}, "", url.toString());
        } catch (error) {
          console.warn("Could not clean forkKey from URL", error);
        }
        return true;
      };

      const initializeMessages = () => {
        const forked = applyForkedConversation();
        if (forked) return;

        const developerRow = addMessageRow("developer");
        applyDeveloperPrefill(developerRow);
        addMessageRow("user");
      };

      wireLoaderButton(loadApproachProposerBtn, "approach-proposer", "Approach Proposer");
      wireLoaderButton(loadApproachEvaluatorBtn, "approach-evaluator", "Approach Evaluator");
      wireLoaderButton(loadProblemSolverBtn, "problem-solver", "Problem Solver");
      wireLoaderButton(loadExpertEvaluatorBtn, "expert-evaluator", "Expert Evaluator");
      wireLoaderButton(loadResearcherBtn, "researcher", "Researcher");
      wireLoaderButton(loadOrchestratorBtn, "orchestrator", "Orchestrator");
      startWorkflowWithBtn?.addEventListener("click", () =>
        startAgenticWorkflow("with_approaches")
      );
      startWorkflowWithoutBtn?.addEventListener("click", () =>
        startAgenticWorkflow("without_approaches")
      );
      resumeWorkflowBtn?.addEventListener("click", () => resumeAgenticWorkflow());
      saveWorkflowBtn?.addEventListener("click", () =>
        saveAgenticState("manual", { createSnapshot: true })
      );
      stopWorkflowBtn?.addEventListener("click", () => stopWorkflow());
      autoRunAgenticCheckbox?.addEventListener("change", () => syncAutoRunControls());
      autoLoopLimitInput?.addEventListener("change", () => normalizeAutoLoopLimitInput());
      initializeAgentConfigs();
      initializeMessages();
      normalizeAutoLoopLimitInput();
      syncAutoRunControls();
      refreshSnapshotList({ silent: true });
      updateStopButtonState();
    </script>
  </body>
</html>
